{"./":{"url":"./","title":"首页 - Spring Boot 青铜篇","keywords":"","body":"悟空笔记 金丝猴们， 该文档定位Spring Boot初学者， 主要帮助大家快速入门，故称为「青铜篇」。 开发环境 jdk 8.0 Spring Boot 2.x Maven 3.x JetBrain Idea 旗舰版 笔记目录 MD 目录结构-Github专属 参考文献 关于作者 贡献 金丝猴们，点击「编辑本页」可以参与悟空笔记修改和补充 欢迎大家指点修正 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/ 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"introduction/introduction.html":{"url":"introduction/introduction.html","title":"开发入门","keywords":"","body":"开发入门 Spring Boot 简介 Spring Boot 优点 快速构建项目 内嵌服务器（Tomcat,Jetty,Undertow），无需部署 war 包 依赖启动器简化构建配置 自动化配置 整合大量第三方库 Spring Boot 应用场景 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/introduction/introduction.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:26 "},"introduction/initialzr-build.html":{"url":"introduction/initialzr-build.html","title":"Spring Initialzr 构建项目","keywords":"","body":"Spring Initialzr 构建项目 悟空编号 sbqt001 配套视频 B 站链接： 使用Spring Initialzr方式构建 Spring Boot 项目 推荐：建议创建父子项目，而不是单体项目 推荐： 使用阿里 Maven 镜像构建项目，速度快 打开 maven 的配置文件 conf/settings.xml，在 标签中添加 mirror 子节点: aliyunmaven * 阿里云公共仓库 https://maven.aliyun.com/repository/public 创建父项目 创建子项目 第 1 步 第 2 步 第 3 步 检查目录结构是否完整 .mvn HELP.md mvnw mvnw.cmd 4 个文件（目录）可以直接删除 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/introduction/initialzr-build.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:27 "},"introduction/modify-banner.html":{"url":"introduction/modify-banner.html","title":"启动Banner图标设置","keywords":"","body":"启动Banner图标设置 悟空编号 sbqt002 配套视频 B 站链接： introduction 修改启动图标 创建 /src/main/resources/banner.txt 文件 通过如下网站设置banner图标样式 http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20 or http://www.degraeve.com/img2txt.php 例如，如下图标复制到 banner.txt 文件中 __ __ .__ .__ __ _ ____ __ | | ______ ____ ____ ____ _____/ |_ ____ __ __| | | | \\ \\/ \\/ / | \\ | |/ / _ \\ / \\ / ___\\ / \\ / _ \\ __\\ / \\| | \\ | | | \\ /| | / | ) | \\/ /_/ > | | ( ) | | | \\ | / |_| |__ \\/\\_/ |____/ |__|_ \\____/|___| /\\___ / |___| /\\____/|__| |___| /____/|____/____/ \\/ \\//_____/ \\/ \\/ 关闭启动图标 banner图标如何关闭 @SpringBootApplication public class App { public static void main( String[] args ) { SpringApplication springApplication = new SpringApplication(App.class); // 关闭 banner 图标 springApplication.setBannerMode(Banner.Mode.OFF); springApplication.run(); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/introduction/modify-banner.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:26 "},"introduction/unit-test.html":{"url":"introduction/unit-test.html","title":"单元测试","keywords":"","body":"单元测试 依赖 pom org.springframework.boot spring-boot-starter-test test service 层单元测试 @SpringBootTest class MySpringbootApplicationTests { @Autowired private HelloController helloController; @Test public void contextLoads() { String hello = helloController.hello(); System.out.println(hello); } } controller层单元测试 视图层代码使用MockMvc 进行测试，这里以UserCntroller 为例,src/test/java 目录下添加测试包 com.wukong.controller 定义测试类代码如下: @RunWith(SpringRunner.class) @SpringBootTest(classes = {Starter.class}) @AutoConfigureMockMvc public class TestUserController { private Logger log = LoggerFactory.getLog ler.class); @Autowired private MockMvc mockMvc; //用户列表查询 @Test public void apiTest01()t MvcResult mvcResu ders.get(\"/user/list\")). andExp Ok()).andReturn(); log.info(\"响 Status()); log.info(\" getContentAsString());; } // 用户名记录查询 @Test public void apiTest02()t MvcResult mvcResult=mockMvc.perform(MockMvcR tBuilders.get(\"/user/uname/admin\")). andExpect(MockMvcResultMatchers.status().isOk()).andReturn(); log.info(\"响应状态:{}\",mvcResult.getResponse().getStatus()); log.info(\"响应内容:{}\",mvcResult.getResponse().getContentAsString());; } } @RunWith(SpringRunner.class) @SpringBootTest(classes = {Starter.class}) @AutoConfigureMockMvc public class TestUserController { private Logger log = LoggerFactory.getLog ler.class); @Autowired private MockMvc mockMvc; //用户列表查询 @Test public void apiTest01()t MvcResult mvcResu ders.get(\"/user/list\")). andExp Ok()).andReturn(); log.info(\"响 Status()); log.info(\" getContentAsString());; } // 用户名记录查询 @Test public void apiTest02()t MvcResult mvcResult=mockMvc.perform(MockMvcR tBuilders.get(\"/user/uname/admin\")). andExpect(MockMvcResultMatchers.status().isOk()).andReturn(); log.info(\"响应状态:{}\",mvcResult.getResponse().getStatus()); log.info(\"响应内容:{}\",mvcResult.getResponse().getContentAsString());; } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/introduction/unit-test.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:27 "},"introduction/hot-deploy.html":{"url":"introduction/hot-deploy.html","title":"热部署","keywords":"","body":"热部署 介绍 实操 pom文件钟添加spring-boot-devtools热部署依赖 org.springframework.boot spring-boot-devtools idea中热部署设置 第1步 第2步 ctrl+shift+alt(option)+/ 打开界面 热部署测试 使用浏览器测试，不需要重复启动main方法 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/introduction/hot-deploy.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:26 "},"introduction/dependency-management.html":{"url":"introduction/dependency-management.html","title":"依赖管理","keywords":"","body":"依赖管理 对依赖进行统一管理 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/introduction/dependency-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:27 "},"introduction/auto-config.html":{"url":"introduction/auto-config.html","title":"自动配置","keywords":"","body":"Spring Boot 自动配置 自动配置 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/introduction/auto-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:26 "},"introduction/execute-flow.html":{"url":"introduction/execute-flow.html","title":"执行流程","keywords":"","body":"Spring Boot 执行流程 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/introduction/execute-flow.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:27 "},"config-annotation/config-annotation.html":{"url":"config-annotation/config-annotation.html","title":"核心配置与注解","keywords":"","body":"核心配置与注解 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/config-annotation/config-annotation.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:27 "},"config-annotation/application-config.html":{"url":"config-annotation/application-config.html","title":"application 官方配置文件","keywords":"","body":"application 官方配置文件 application.properties配置文件 配置端口号 #配置端口号 server.port=8090 #配置虚拟路径 server.servlet.context-path=/project-name application.yaml配置文件 #端口号 虚拟路径 server: port: 8091 servlet: context-path: /project-name2 注意 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/config-annotation/application-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:26 "},"config-annotation/inject-property.html":{"url":"config-annotation/inject-property.html","title":"属性注入","keywords":"","body":"属性注入 @ConfigurationProperties注入属性 第 1 种方法 properties #给类属性赋值 person.id=1 person.name=wukongnotnull person.family=baba,mama,gege,jiejie person.hobbies=dance,game,110 person.map.level=3 person.map.salary=3000 person.pet.petName=wangcai person.pet.petAge=3 第二种方式yml #给类属性赋值 person: id: 2 name: wukongnotnull family: [baba,mama,gege,jiejie] hobbies: [dance,game,sing] map: {level: 3,salary: 3000} pet: {petName: wangcai, petAge: 3} 编写实体类 package com.wukongnotnull.domain; /* author: 悟空非空也（B站/知乎/公众号） */ public class Pet { private String petName; private int petAge; public String getPetName() { return petName; } public void setPetName(String petName) { this.petName = petName; } public int getPetAge() { return petAge; } public void setPetAge(int petAge) { this.petAge = petAge; } @Override public String toString() { return \"Pet{\" + \"petName='\" + petName + '\\'' + \", petAge=\" + petAge + '}'; } } 使用@Component,@ConfigurationProperties注解 package com.wukongnotnull.domain; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import java.util.Arrays; import java.util.List; import java.util.Map; @Component @ConfigurationProperties(prefix = \"person\") public class Person { private int id; private String name; private String[] family; private List hobbies; private Map map; private Pet pet; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public List getHobbies() { return hobbies; } public void setHobbies(List hobbies) { this.hobbies = hobbies; } public String[] getFamily() { return family; } public void setFamily(String[] family) { this.family = family; } public Map getMap() { return map; } public void setMap(Map map) { this.map = map; } public Pet getPet() { return pet; } public void setPet(Pet pet) { this.pet = pet; } @Override public String toString() { return \"Person{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", family=\" + Arrays.toString(family) + \", hobbies=\" + hobbies + \", map=\" + map + \", pet=\" + pet + '}'; } } 测试类 @SpringBootTest class MySpringbootApplicationTests { @Autowired private Person person; @Test public void personTest(){ System.out.println(person); } } @Value 注入属性 @Value直接注入属性 person: id: 2 name: wukongnotnull family: [baba,mama,gege,jiejie] hobbies: [dance,game,sing] map: {level: 3,salary: 3000} pet: {petName: wangcai, petAge: 3} flag: wukong 测试 @SpringBootTest class MySpringbootApplicationTests { @Value(value=\"${flag}\") private String flag; @Value(value = \"${person.id}\") private Integer id; @Value(value = \"${person.name}\") private String name; @Value(value = \"${person.family[0]}\") private String familyOne; @Value(value = \"${person.family}\") private List family; @Value(value = \"${person.hobbies[0]}\") private String hobbiesOne; @Value(value=\"${person.hobbies}\") private String[] hobbies; // 对于自定义对象或者Map类型的数据，需要直接取属性值 @Value(value = \"${person.map.level}\") private Integer level; @Value(value=\"${person.pet.petName}\") private String petName; //报错：llegalArgumentException: Could not resolve placeholder 'person.pet' in value \"${person.pet}\" /* @Value(value = \"${person.pet}\") private Pet pet;*/ @Test void testValue(){ System.out.println(\"flag = \" + flag); System.out.println(\"id = \" + id); System.out.println(\"name = \" + name); System.out.println(\"familyOne = \" + familyOne); System.out.println(\"family = \" + family); System.out.println(\"hobbiesOne = \" + hobbiesOne); System.out.println(\"hobbies = \" + Arrays.toString(hobbies)); System.out.println(\"level = \" + level); System.out.println(\"petName = \" + petName); /* System.out.println(\"pet = \" + pet);*/ } } 两种注解对比分析 @ConfigurationProperties注解支持JSR303数据校验 application.properties #@ConfigurationProperties注解支持JSR303数据校验 user.email=1390128154@qq.com pom org.springframework.boot spring-boot-starter-validation 实体类 package com.wukongnotnullg.myspringboot.domain; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import org.springframework.validation.annotation.Validated; import javax.validation.constraints.Email; @Component @ConfigurationProperties(prefix = \"user\") @Validated public class User { @Email private String email; public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } } test @SpringBootTest class ApplicationTests { @Autowired private User user; @Test void emailValidation() { System.out.println(\"user = \" + user); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/config-annotation/inject-property.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:26 "},"config-annotation/custom-config.html":{"url":"config-annotation/custom-config.html","title":"自定义配置文件","keywords":"","body":"自定义配置文件 使用 @PropertySource 加载自定义配置文件 @PropertySource 源码 public @interface PropertySource { /** * Indicate the resource location(s) of the properties file to be loaded. * Both traditional and XML-based properties file formats are supported * &mdash; for example, {@code \"classpath:/com/myco/app.properties\"} * or {@code \"file:/path/to/file.xml\"}. * Resource location wildcards (e.g. *&#42;/*.properties) are not permitted; * each location must evaluate to exactly one {@code .properties} or {@code .xml} * resource. * ${...} placeholders will be resolved against any/all property sources already * registered with the {@code Environment}. See {@linkplain PropertySource above} * for examples. * Each location will be added to the enclosing {@code Environment} as its own * property source, and in the order declared. */ String[] value(); 案例 自定义配置文件 test.properties #自定义配置文件 test.id=1 test.name=wukongnotnull 实体类 package com.wukongnotnull.myspringboot.domain; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; import org.springframework.stereotype.Component; /** * @Author: 悟空非空也（公众号/B站/知乎） */ //注意：可以使用@Component代替 //@Configuration+@EnableConfigurationProperties(MyProperties.class) @Configuration//指定当前类为配置类 @EnableConfigurationProperties(MyProperties.class)//开启配置文件的属性注入功能 @PropertySource(value=\"classpath:test.properties\")//指定自定义配置文件的来源 @ConfigurationProperties(prefix = \"test\") public class MyProperties { private int id; private String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"MyProperties{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; } } 测试 @SpringBootTest class MySpringbootApplicationTests { @Autowired private MyProperties myProperties; @Test public void myPropertiesTest(){ System.out.println(\"myProperties===>\"+myProperties); } } 使用@ImportResource加载自定义的 spring xml 配置文件 @ImportResource 源码 public @interface ImportResource { /** * Resource locations from which to import. * Supports resource-loading prefixes such as {@code classpath:}, * {@code file:}, etc. * Consult the Javadoc for {@link #reader} for details on how resources * will be processed. * @since 4.2 * @see #value * @see #reader */ @AliasFor(\"value\") String[] locations() default {}; 案例 创建 spring xml 配置文件myBeans.xml 启动类上添加 @ImportResource 注解 package com.wukongnotnull; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.ImportResource; @SpringBootApplication @ImportResource(value = \"classpath:myBeans.xml\") public class InitializrProjectApplication { public static void main(String[] args) { SpringApplication.run(InitializrProjectApplication.class, args); } } test @SpringBootTest class InitializrProjectApplicationTests { @Autowired private ApplicationContext applicationContext; @Test void beansTest(){ Pet myPet =(Pet) applicationContext.getBean(\"myPet\"); System.out.println(\"myPet----->\" + myPet); } } 使用 @Configuration 编写自定义配置类 @Configuration 源码 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Configuration { /** * Explicitly specify the name of the Spring bean definition associated with the * {@code @Configuration} class. If left unspecified (the common case), a bean * name will be automatically generated. * The custom name applies only if the {@code @Configuration} class is picked * up via component scanning or supplied directly to an * {@link AnnotationConfigApplicationContext}. If the {@code @Configuration} class * is registered as a traditional XML bean definition, the name/id of the bean * element will take precedence. * @return the explicit component name, if any (or empty String otherwise) * @see AnnotationBeanNameGenerator */ @AliasFor(annotation = Component.class) String value() default \"\"; /** * Specify whether {@code @Bean} methods should get proxied in order to enforce * bean lifecycle behavior, e.g. to return shared singleton bean instances even * in case of direct {@code @Bean} method calls in user code. This feature * requires method interception, implemented through a runtime-generated CGLIB * subclass which comes with limitations such as the configuration class and * its methods not being allowed to declare {@code final}. * The default is {@code true}, allowing for 'inter-bean references' via direct * method calls within the configuration class as well as for external calls to * this configuration's {@code @Bean} methods, e.g. from another configuration class. * If this is not needed since each of this particular configuration's {@code @Bean} * methods is self-contained and designed as a plain factory method for container use, * switch this flag to {@code false} in order to avoid CGLIB subclass processing. * Turning off bean method interception effectively processes {@code @Bean} * methods individually like when declared on non-{@code @Configuration} classes, * a.k.a. \"@Bean Lite Mode\" (see {@link Bean @Bean's javadoc}). It is therefore * behaviorally equivalent to removing the {@code @Configuration} stereotype. * @since 5.2 */ boolean proxyBeanMethods() default true; } 案例 编写配置类 package com.wukongnotnull.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @Author: 悟空非空也（公众号/B站/知乎） */ @Configuration //定义该类为配置类 public class MyConfig { @Bean(name = \"aPet\") public Pet getPetInstance(){ return new Pet(); } } public class Pet { // properties } 测试 @Autowired private ApplicationContext applicationContext; @Test public void myServiceTest(){ Pet aPet = (Pet)applicationContext.getBean(\"aPet\"); System.out.println(aPet); } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/config-annotation/custom-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 17:26:42 "},"config-annotation/profile-config.html":{"url":"config-annotation/profile-config.html","title":"Profile 文件配置","keywords":"","body":"profile 文件配置 多环境配置文件格式 方法一 使用命令行方式激活指定环境的配置文件 ctrl+c 服务器运行退出 ctrl+c 停止 方法二 在全局配置文件application.properties设置 spring.profiles.active属性激活 spring.profiles.active=test 案例 1 不同环境下使用不同端口 创建不同环境下配置文件 application.yml spring: profiles: active: test application-dev.yml server: port: 8081 application-prod.yml server: port: 8082 application-test.yml server: port: 8083 运行 main 方法，查看控制台的端口号输出信息 案例 2 不同环境下使用不同数据库 使用 @Profile 注解进行多环境配置 编写不同环境下的配置类 package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ public interface DBConnector { /** * 对不同的环境下的数据库设置统一接口约束 */ void configuration(); } package com.wukongnotnull.config;/* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; @Configuration @Profile(value = \"dev\") public class DevDBConnector implements DBConnector{ @Override public void configuration() { System.out.println(\"开发环境下连接数据库。。。\"); } } package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; @Configuration @Profile(value = \"pro\") public class ProDBConnector implements DBConnector{ @Override public void configuration() { System.out.println(\"生产环境下连接数据库。。。。。\"); } } package com.wukongnotnull.config;/* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; @Configuration @Profile(value = \"test\") public class TestDBConnector implements DBConnector{ public void configuration() { System.out.println(\"测试环境下连接数据库。。。。\"); } } 在全局配置文件application.properties中指定使用哪个环境 spring.profiles.active=test #或者 #spring.profiles.active=pro #或者 #spring .profiles.active=dev 测试 @Autowired private DBConnector dbConnector; @Test public void dbConnectorTest(){ dbConnector.configuration(); } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/config-annotation/profile-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 17:29:52 "},"config-annotation/property-reference.html":{"url":"config-annotation/property-reference.html","title":"yml 高级玩法","keywords":"","body":"yml 高级玩法 参数间引用 application.properties # 参数间的引用 app.name=wukongnotnull app.description=${app.name} is a technology blog website, welcome your comming. wukong.age=${random.int[10,20]} wukong.description=悟空非空也的年龄可能是 ${wukong.age} test @SpringBootTest class MySpringbootApplicationTests { @Value(\"${wukong.description}\") private String authorDes; @Test void contextLoads() { System.out.println(authorDes); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/config-annotation/property-reference.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:27 "},"data-access/data-access.html":{"url":"data-access/data-access.html","title":"数据访问","keywords":"","body":"Spring Boot 数据访问概述 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/data-access/data-access.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:27 "},"data-access/env-setup.html":{"url":"data-access/env-setup.html","title":"环境搭建","keywords":"","body":"基础环境搭建 创建数据库 CREATE DATABASE wukong_blog; USE wukong_blog; CREATE TABLE `b_article` ( `id` INT(20) NOT NULL AUTO_INCREMENT COMMENT '文章id', `title` VARCHAR(200) DEFAULT NULL COMMENT '文章标题', `content` LONGTEXT COMMENT '文章内容', PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO `b_article` VALUES ('1', 'Spring Boot 青铜篇', '从入门到放弃讲解...'); INSERT INTO `b_article` VALUES ('2', 'Spring Cloud 王者篇', '从入门到入土讲解...'); CREATE TABLE `b_comment` ( `id` INT(20) NOT NULL AUTO_INCREMENT COMMENT '评论id', `content` LONGTEXT COMMENT '评论内容', `author` VARCHAR(200) DEFAULT NULL COMMENT '评论作者', `article_id` INT(20) DEFAULT NULL COMMENT '外键：文章id', PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO `b_comment` VALUES ('1', '赞1', 'wukong', '1'); INSERT INTO `b_comment` VALUES ('2', '赞2', 'zhubajie', '1'); INSERT INTO `b_comment` VALUES ('3', '赞3', 'tangseng', '1'); INSERT INTO `b_comment` VALUES ('4', '赞4', 'bailongma', '2'); INSERT INTO `b_comment` VALUES ('5', '赞5', 'baigujing', '2'); 创建项目,引入mysql的依赖启动器 创建实体类domain 推荐实体类使用 lombok 插件，编译后自动生成 setter | getter 方法。 package com.wukongnotnull.domain; /* author: 悟空非空也（B站/知乎/公众号） */ import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.ToString; @Data @NoArgsConstructor @AllArgsConstructor public class Article { private Integer id; private String title; private String content; } package com.wukongnotnull.domain; /* author: 悟空非空也（B站/知乎/公众号） */ import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.ToString; @Data @NoArgsConstructor @AllArgsConstructor public class Comment { private Integer id; private String content; private String author; //此属性名和表中的字段article_id不一致，不能自动映射，需要在application.yml中进行配置 //mybatis.configuration.map-underscore-to-camel-case=true private Integer articleId; } 全局配置文件进行数据库连接配置 application.yml spring: datasource: url: jdbc:mysql://localhost:3306/wukong_blog?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&autoReconnect=true driver-class-name: com.mysql.cj.jdbc.Driver username: root password: rootroot 使用第三方数据源进行配置（推荐：ali的druid数据源为例） pom.xml com.alibaba druid-spring-boot-starter 1.1.22 在全局配置文件中设置druid的属性 application.yml spring: datasource: type: com.alibaba.druid.pool.DruidDataSource initialSize: 30 minIdle: 20 maxActive: 200 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/data-access/env-setup.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 17:42:46 "},"data-access/integrate-mybatis.html":{"url":"data-access/integrate-mybatis.html","title":"整合 MyBatis","keywords":"","body":"整合MyBatis 使用注解的方式整合MyBatis mapper接口 package com.wukongnotnull.mapper; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Comment; import org.apache.ibatis.annotations.*; @Mapper public interface CommentMapper { // 查询 @Select(\"select * from b_comment where id = #{id}\") public Comment queryComment(Integer id); //删除 @Delete(\"delete from b_comment where id=#{id}\") public int deleteComment(@Param(\"id\") Integer id); // 修改 @Update(\"update b_comment set content = #{content}, author = #{author} where id = #{id}\") public int updateComment(Comment comment); // 添加，注意是 #{articleId} ，不是#{article_id} @Insert(\"insert into b_comment(content,author,article_id) values(#{content},#{author},#{articleId})\") public int insertComment(Comment comment); } 测试 package com.wukongnotnull.mapper; import com.wukongnotnull.domain.Comment; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; /* author: 悟空非空也（B站/知乎/公众号） */ @SpringBootTest class CommentMapperTest { @Autowired private CommentMapper commentMapper; @Test void queryComment() { System.out.println(commentMapper.queryComment(2)); } @Test void deleteComment() { System.out.println(commentMapper); System.out.println(commentMapper.deleteComment(5)); } @Test void updateComment(){ Comment comment = new Comment(); comment.setId(2); comment.setContent(\"11111\"); comment.setAuthor(\"111\"); System.out.println(commentMapper.updateComment(comment)); } @Test void insertComment(){ Comment comment = new Comment(); comment.setContent(\"add11111\"); comment.setAuthor(\"add11111\"); comment.setArticleId(1); System.out.println(commentMapper.insertComment(comment)); } } 使用配置文件的方式整合MyBatis 在全局配置文件配置 mapper-locations: classpath:mapper/** 该位置是在 resources 文件夹下新建 mapper 目录 mybatis: configuration: map-underscore-to-camel-case: true mapper-locations: classpath:mapper/** type-aliases-package: com.wukongnotnull.domain 编写ArticleMapper接口 package com.wukongnotnull.mapper; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Article; import org.apache.ibatis.annotations.Mapper; import org.springframework.stereotype.Component; import java.util.List; // 不要忘记 @Mapper @Mapper public interface ArticleMapper { // 查询单文章 Article getArticleById(int id); // 查询文章列表 List getArticleList(); // 修改文章 int updateArticle(Article article); // 添加文章 int addArticle(Article article); // 删除文章 int delArticle(int id); } 编写接口对应的xml配置文件 select * from b_article where id = #{id} select * from b_article update b_article set title = #{title}, content = #{content} where id = #{id} insert into b_article(title,content) values(#{title},#{content}) delete from b_article where id = #{id} 测试 package com.wukongnotnull.mapper; import com.wukongnotnull.domain.Article; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import static org.junit.jupiter.api.Assertions.*; /* author: 悟空非空也（B站/知乎/公众号） */ @SpringBootTest class ArticleMapperTest { @Autowired private ArticleMapper articleMapper; @Test void delArticle(){ System.out.println(articleMapper.delArticle(3)); } @Test void addArticle(){ Article article = new Article(); article.setTitle(\"add 1029\"); article.setContent(\"add content 1030\"); System.out.println(articleMapper.addArticle(article)); } @Test void updateArticle(){ Article article = new Article(); article.setId(2); article.setTitle(\"update 1026...\"); article.setContent(\"content 1026\"); System.out.println(articleMapper.updateArticle(article)); } @Test void getArticleList(){ System.out.println(articleMapper.getArticleList()); } @Test void getArticleById() { System.out.println(articleMapper.getArticleById(1)); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/data-access/integrate-mybatis.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:27 "},"data-access/integrate-jpa.html":{"url":"data-access/integrate-jpa.html","title":"整合 JPA","keywords":"","body":"整合 JPA Spring Date JPA 介绍 Spring Data 是Spring的一个子项目，旨在统一和简化各类型数据的持久化存储方式，而不拘泥于是关系型数据库还是NoSQL数据库。无论是哪种持久化存储方式，数据访问对象（Data Access Objects，DAO）都会提供对对象的增加、删除、修改和查询的方法，以及排序和分页方法等。 Spring Data 提供了基于这些层面的统一接口（如：CrudRepository、 PagingAndSortingRepository），以实现持久化的存储。 JPA（Java Persistence API）是Java的持久化API，用于对象的持久化。它是一个非常强大的ORM持久化的解决方案，免去了使用JDBCTemplate开发的编写脚本工作。JPA通过简单约定好接口方法的规则自动生成相应的JPQL语句，然后映射成POJO对象。 JPA是一个规范化接口，封装了Hibernate的操作作为默认实现，让用户不通过任何配置即可完成数据库的操作。 Spring Boot 整合 JPA pom 依赖 org.springframework.boot spring-boot-starter-data-jpa mysql mysql-connector-java runtime 配置文件 spring: datasource: url: jdbc:mysql://localhost:3306/wukong_blog?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&autoReconnect=true driver-class-name: com.mysql.cj.jdbc.Driver username: root password: rootroot 实体类与表的映射 package com.wukongnotnull.domain;/* author: 悟空非空也（B站/知乎/公众号） */ import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; @Data @NoArgsConstructor @AllArgsConstructor @Entity(name = \"b_comment\") public class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = \"content\" ) private String content; @Column(name = \"author\") private String author; @Column(name = \"article_id\") private Integer articleId; } 自定义接口 默认继承父接口，父接口提供了简单的增删改查方法，还不能满足业务需求，那就需要自定义方法 package com.wukongnotnull.repository; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Comment; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import javax.transaction.Transactional; import java.util.List; import java.util.Optional; // 记得添加该注解 @Repository @Repository public interface CommentRepository extends JpaRepository { @Override List findAll(); @Override Optional findById(Integer id); // 查询条件：作者不为空 List findByAuthorNotNull(); @Override long count(); @Override S saveAndFlush(S s); // 不能使用 * 通配符 @Query(\"select c from b_comment c where c.articleId=?1\",nativeQuery = false) List getCommentList(Integer articleId); // 若使用通配符 * @Query(value = \"select * from b_comment c where c.articleId=?1\",nativeQuery = true) List getCommentList2(Integer articleId); @Transactional @Modifying @Query(value = \"update b_comment set author =?1 where id =?2 \",nativeQuery = true) int updateComment(String author,Integer id); @Transactional @Modifying @Query(value = \"delete from b_comment where id = ?1\",nativeQuery = true) int deleteComment(Integer id); @Override S save(S entity); } 单元测试 package com.wukongnotnull.repository; import com.wukongnotnull.domain.Comment; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; /* author: 悟空非空也（B站/知乎/公众号） */ @SpringBootTest class CommentRepositoryTest { @Autowired private CommentRepository commentRepository; @Test void findAll() { System.out.println(commentRepository.findAll()); } @Test void findById(){ Optional optionalComment = commentRepository.findById(1); if (optionalComment.isPresent()) { Comment comment1 = optionalComment.get(); System.out.println(comment1); } } @Test void findByAuthorNotNull(){ System.out.println(commentRepository.findByAuthorNotNull()); } @Test void count(){ System.out.println(commentRepository.count()); } @Test void getCommentList(){ System.out.println(commentRepository.getCommentList(1)); } @Test void getCommentList2(){ System.out.println(commentRepository.getCommentList2(1)); } @Test void updateComment(){ System.out.println(commentRepository.updateComment(\"6666\", 6)); } @Test void deleteComment(){ System.out.println(commentRepository.deleteComment(6)); } @Test void save(){ Comment comment = new Comment(); comment.setAuthor(\"wukongnotnull0716\"); comment.setContent(\"content .... wukong ...\"); System.out.println(commentRepository.save(comment)); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/data-access/integrate-jpa.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-24 16:21:41 "},"data-access/integrate-redis.html":{"url":"data-access/integrate-redis.html","title":"整合 Redis","keywords":"","body":"Spring Boot 整合 Redis Redis 简介 Redis 概念 Redis 是一个开源（BSD许可）的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件，并提供多种语言的API。 优点 存取速度快：Redis速度非常快，每秒可执行大约110000次的设值操作，或者执行81000次的读取操作。 支持丰富的数据类型：Redis支持开发人员常用的大多数数据类型，例如列表、集合、排序集和散列等。 操作具有原子性：所有Redis操作都是原子操作，这确保如果两个客户端并发访问，Redis服务器能接收更新后的值。 提供多种功能：Redis提供了多种功能特性，可用作非关系型数据库、缓存中间件、消息中间件等。 Redis下载与安装 下载路径 https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100 解压后放入磁盘某位置就安装成功（免安装） 安装可视化客户端 推荐安装 Redis Desktop Manager 客户端 Spring Boot 整合 Redis 依赖启动器 在pom文件中添加Spring Data Redis依赖启动器 org.springframework.boot spring-boot-starter-data-redis 配置 在全局配置文件application.properties中添加Redis数据库连接配置 spring: redis: host: 127.0.0.1 port: 6379 password: 编写实体类 package com.wukongnotnull.domain;/* author: 悟空非空也（B站/知乎/公众号） */ import lombok.Data; import org.springframework.data.annotation.Id; import org.springframework.data.redis.core.RedisHash; import org.springframework.data.redis.core.index.Indexed; import java.util.List; @Data @RedisHash(value = \"people\") public class Person { @Id private String id; @Indexed private String firstName; @Indexed private String lastName; private Address address; private List familyList; } package com.wukongnotnull.domain;/* author: 悟空非空也（B站/知乎/公众号） */ import lombok.Data; import org.springframework.data.redis.core.index.Indexed; @Data public class Address { @Indexed private String nation; @Indexed private String village; } package com.wukongnotnull.domain;/* author: 悟空非空也（B站/知乎/公众号） */ import lombok.Data; import org.springframework.data.redis.core.index.Indexed; @Data public class Family { @Indexed private String type; @Indexed private String name; } 编写 Repository 接口 package com.wukongnotnull.repository;/* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Person; import org.springframework.data.repository.CrudRepository; public interface PersonRepository extends CrudRepository { Person findPersonByFirstName(String firstName); @Override S save(S entity); } 单元测试 编写单元测试进行接口方法测试以及整合测试 package com.wukongnotnull.repository; import com.wukongnotnull.domain.Address; import com.wukongnotnull.domain.Family; import com.wukongnotnull.domain.Person; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.ArrayList; import java.util.List; /* author: 悟空非空也（B站/知乎/公众号） */ @SpringBootTest class PersonRepositoryTest { @Autowired private PersonRepository personRepository; @Test void findPersonByFirstName() { System.out.println(personRepository.findPersonByFirstName(\"空\")); } @Test void save() { Person person = new Person(); person.setId(\"001\"); person.setLastName(\"悟\"); person.setFirstName(\"空\"); Address address = new Address(); address.setNation(\"中国\"); address.setVillage(\"南京\"); person.setAddress(address); List familyList = new ArrayList<>(); Family father = new Family(); father.setType(\"father\"); father.setName(\"杨康\"); Family mother = new Family(); mother.setType(\"mother\"); mother.setName(\"穆念慈\"); familyList.add(father); familyList.add(mother); person.setFamilyList(familyList); System.out.println(personRepository.save(person)); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/data-access/integrate-redis.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-25 10:15:40 "},"log-management/log-management.html":{"url":"log-management/log-management.html","title":"日志管理","keywords":"","body":"日志管理 开启日志 debug: true #开启日志 logging: level: com.wukongnotnull: debug #设置日志级别 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/log-management/log-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-24 10:12:06 "},"log-management/default-log.html":{"url":"log-management/default-log.html","title":"默认日志管理","keywords":"","body":"默认日志管理 默认日志框架 logback java web 有多种日志框架，比如：logback，log4j，log4j2（slj4f 并不是一种日志框架，它相当于定义了规范，实现了这个规范的日志框架就能够用 slj4f 调用）。 其中性能最高的应该使 logback ，Spring Boot 默认使用的也是 logback 日志。 默认情况下 Spring Boot 将 info 级别的日志输出到控制台中，不会写到日志文件，且不能进行复杂配置。 import org.slf4j.Logger; import org.slf4j.LoggerFactory; Logger logger = LoggerFactory.getLogger(App.class); logger.info(\"我是 springboot的默认日志系统.....\"); 日志的复杂配置 写到日志文件中。如果要编写除控制台输出之外的日志文件，则需要application.yml中设置logging.file 或者logging.path属性。 logging: file: # 项目路径下的log目录下的spring.log 文件（默认名为 spring.log） path: ./log # 自定义日志名，存放在项目路径下 （name 优先级高于 path） name: ./resources.log 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/log-management/default-log.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-24 15:44:41 "},"aop-intergrate/aop-intergrate.html":{"url":"aop-intergrate/aop-intergrate.html","title":"整合 AOP","keywords":"","body":"Spring Boot 整合 AOP AOP 在SpringBoot中默认是开启AOP功能的 spring: aop: auto: true 使用步骤 添加依赖 org.springframework.boot spring-boot-starter-aop 自定义注解 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface InvokeLog { } 定义切面类 import org.slf4j.Logger; import org.slf4j.LoggerFactory; @Aspect //标识这是一个切面类 @Component public class InvokeLogAspect { public static final Logger logger = LoggerFactory.getLogger(InvokeLogAspect.class); //指定哪些连接点为切点 @Pointcut(\"@annotation(com.wukongnotnull.aop.InvokeLog)\") public void pc(){ } // 在切点出添加什么增强，增强方式是什么？ @Around(\"cp()\") public Object printInvokeLog(ProceedingJoinPoint joinPoint){ //目标方法调用前 Object proceed = null; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); String methodName = signature.getMethod().getName(); logger.info(\"enter this method--->\"+methodName); try { proceed = joinPoint.proceed(); //目标方法调用后 logger.info(\"leave this method--->\"+methodName); } catch (Throwable throwable) { throwable.printStackTrace(); } return proceed; } } 增加自定义注解 @Service public class UserServiceImpl implements UserServcie { @Autowired private UserMapper userMapper; @Override @InvokeLog //添加自定义注解 public List findAll() { return userMapper.findAll(); } } 单元测试 @Test void findAll() { userService.findAll(); } 切换动态代理 有的时候我们需要修改AOP的代理方式。 我们可以使用以下方式修改： 在配置文件中配置spring.aop.proxy-target-class为false这为使用jdk动态代理。该配置默认值为true，代表使用cglib动态代理。 @SpringBootApplication @EnableAspectJAutoProxy(proxyTargetClass = false)//修改代理方式 public class WebApplication { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(WebApplication.class, args); } } 如果想生效还需要在配置文件中做如下配置 spring: aop: proxy-target-class: false #切换动态代理的方式 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/aop-intergrate/aop-intergrate.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-25 15:23:26 "},"transaction-management/transaction-management.html":{"url":"transaction-management/transaction-management.html","title":"事务管理","keywords":"","body":"事务管理 Spring Boot 集成了Mybatis框架，Mybatis底层数据访问层实现基于jdbc 来实现，所以在Spring Boot 环境下对 事物进行控制，事务实现由Spring Boot实现并自动配置，在使用时通过注解方式标注相关方法加入事务控制即可 @Service public class UserServiceImpl implements UserService { @Resource private UserMapper userMapper; //增删改上添加 该注解即可 （查询不需要） @Transactional(propagation = Propagation.REQUIRED) public void addUser(User user) { ...... ...... } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/transaction-management/transaction-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:17:26 "},"view-tech/view-tech.html":{"url":"view-tech/view-tech.html","title":"视图技术","keywords":"","body":"Spring Boot 支持的视图技术 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/view-tech/view-tech.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"view-tech/static-resource.html":{"url":"view-tech/static-resource.html","title":"访问静态资源","keywords":"","body":"Spring Boot 访问静态资源 访问静态资源 由于SpringBoot的项目一般打成jar包，项目结构中没有 webapps 目录。 那么，静态资源要放到哪里呢？ Spring Boot 源码告诉我们，将静态资源放到 resources/static (或者 resources/public 或者resources/resources 或者 resources/META-INF/resources) 中即可。 修改存放目录 根据 spring.web.resources.static-locations 自定义静态资源存放位置。 可以存放在 src/main/resources/static/ 或者 src/main/resources/public/ 或者 src/main/resources/wukong/ spring: web: resources: static-locations: classpath:/static/,classpath:/public/,classpath:/wukong/ css 和 js , 同理 http://localhost:8080/wukong/mycss.css http://localhost:8080/wukong/myjs.js 也可以分别被引入到html页面中 修改访问路径 Spring Boot 默认静态资源的路径匹配为/** 。 想要修改请设置 spring.mvc.static-path-pattern 。 在application.yml中 spring: mvc: static-path-pattern: /wk/** #修改静态资源访问路径 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/view-tech/static-resource.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-26 15:46:30 "},"view-tech/thymeleaf.html":{"url":"view-tech/thymeleaf.html","title":"整合 Thymeleaf","keywords":"","body":"Spring Boot 整合 Thymeleaf Thymeleaf 介绍 Thymeleaf 官网https://www.thymeleaf.org/index.html Thymeleaf is a modern server-side Java template engine for both web and standalone environments. Thymeleaf's main goal is to bring elegant natural templates to your development workflow — HTML that can be correctly displayed in browsers and also work as static prototypes, allowing for stronger collaboration in development teams. With modules for Spring Framework, a host of integrations with your favourite tools, and the ability to plug in your own functionality, Thymeleaf is ideal for modern-day HTML5 JVM web development — although there is much more it can do. Natural templates HTML templates written in Thymeleaf still look and work like HTML, letting the actual templates that are run in your application keep working as useful design artifacts. Name Price Oranges 0.99 官网教学文档https://www.thymeleaf.org/documentation.html Thymeleaf 常用标签 Thymeleaf 标准表达式 整合 Thymeleaf 创建springboot项目 org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web application.yml 中配置 Thymeleaf 模板缓存 开发测试时，请关闭缓存。 spring: thymeleaf: mode: HTML prefix: classpath:/templates/ suffix: .html cache: false # 关闭缓存 encoding: UTF-8 使用 Thymeleaf 完成数据的页面展示 使用Thymeleaf配置国际化页面 前端资源目录结构 前端资源下载链接 https://share.weiyun.com/iVq52myH login.html 用户登录界面 请登录 [[#{login.rememberme}]] 登录 © 2018-2019 中文 English login.properties login.tip=请登录 login.username=用户名 login.password=密码 login.rememberme=记住我 login.button=登录 login_zh_CN.properties login.tip=请登录 login.username=用户名 login.password=密码 login.rememberme=记住我 login.button=登录 login_en_US.properties login.tip=Please sign in login.username=Username login.password=Password login.rememberme=Remember me login.button=Login 在application.properties中配置国际化文件的基础名 #配置国际化文件基础名 spring.messages.basename=i18n.login 定制区域化解析器 在 com.wukongnotnull.config 下创建 MyLocaleResolver 类 package com.wukongnotnull.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.lang.Nullable; import org.springframework.util.StringUtils; import org.springframework.web.servlet.LocaleResolver; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Locale; @Configuration public class MyLocaleResolver implements LocaleResolver { // 自定义区域解析方式 @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) { // 获取页面手动切换传递的语言参数l String l = httpServletRequest.getParameter(\"l\"); // 获取请求头自动传递的语言参数Accept-Language String header = httpServletRequest.getHeader(\"Accept-Language\"); Locale locale=null; // 如果手动切换参数不为空，就根据手动参数进行语言切换，否则默认根据请求头信息切换 if(!StringUtils.isEmpty(l)){ String[] split = l.split(\"_\"); locale=new Locale(split[0],split[1]); }else { // Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 String[] splits = header.split(\",\"); String[] split = splits[0].split(\"-\"); locale=new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest httpServletRequest, @Nullable HttpServletResponse httpServletResponse, @Nullable Locale locale) { } // 将自定义的MyLocaleResolver类重新注册为一个类型LocaleResolver的Bean组件 @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } } controller package com.wukongnotnull.controller; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import java.util.Calendar; @Controller public class IndexController { @GetMapping(value = \"/login\") public String login(){ return \"login\"; } @GetMapping(value = \"/toLoginPage\") public String toLoginPage(Model model){ int currentYear = Calendar.getInstance().get(Calendar.YEAR); model.addAttribute(\"currentYear\",currentYear); return \"login\"; } } 启动后，浏览器发送请求，进行测试 中文乱码解决 application 文件中出现中文乱码，请如下设置 在创建新项目前，将idea进行字符编码设置，这样保证项目和配置文件中的所有中文打字都是使用utf-8编码 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/view-tech/thymeleaf.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-26 15:55:20 "},"view-tech/freemarker.html":{"url":"view-tech/freemarker.html","title":"整合 Freemarker","keywords":"","body":"Spring Boot 整合 Freemarker Freemarker 介绍 官方网站 https://freemarker.apache.org/ 中文网站 http://freemarker.foofun.cn/toc.html 集成 Freemarker 视图 Spring Boot内部支持 Freemarker 视图技术的集成，并提供了自动化配置类 FreeMarkerAutoConﬁguration ，借助自动化配置可以很方便的集成Freemarker 视图到SpringBoot环境中。 pom 依赖 org.springframework.boot spring-boot-starter-freemarker 修改 Freemarker 配置信息 Freemarker 默认视图路径为 resources/templates 目录(由自动化配置类FreemarkerProperties 类决定)， 该目录可以在application.yml 中进行修改。 spring: freemarker: charset: utf-8 content-type: text/html # 默认是 resources/templates ,改成 resources/views template-loader-path: classpath:/views/ suffix: .ftl controller @RequestMapping(\"/hello\") public String showHello(){ return \"hello\"; } resources/views/hello.ftl hello ,悟空非空也，我是freemarker模板 Freemarker 常用语法 FreeMarker 三种语法： 插值：${...}，Freemarker 会将里面的变量替换为实际值。 FTL 标签(tags)：结构上类似HTML的标签，都是用<>包裹起来，普通标签以开头，用户自定义标签以开头，如true thing， 标签（tags）和 指令（directive）的区分 举个例子： 叫标签； 标签里面的 if 是指令。 注释(Comments)：FTL 中的注释是：，对于注释，FTL会自动跳过，所以不会显示在生成的文本中。 注意：除以上三种语法之外的所有内容，皆被 FreeMarker 视为普通文本，普通文本会被原样输出 if 指令 if 可以根据条件跳过模板中的某块代码，当 userName 值为 \"悟空非空也\" 或wukongnotnull时，用特殊样式展示，相关模板代码如下： 你好， ${userName} ${userName} ${userName} list 指令 list 用来遍历序列，其语法为： repeatThis 后端 model 里放入一个 userList 的集合 model.addAttribute(\"userList\",userService.getUserList()); 可以直接使用下标访问集合中的某个元素：${userList[0].name} 也可以在模板中直接遍历展示： 姓名：${user.name}，年龄：${user.age} 渲染出 HTML： 姓名：wukong，年龄：100 姓名：zhubajie，年龄：200 姓名：shaseng，年龄：300 注意：假设 userList 是空的，渲染出页面为 ，如何规避，使用 items 标签 姓名：${user.name}，年龄：${user.age} include 指令 include 指令把一个模板的内容插入到另一个模板中。（官方建议使用 import 代替）。 若每个页面都添加 footer，可以编写一个公共的 footer.ftl 模板，每个页面直接引入即可。 import 指令 import 将模板中定义的变量引入当前模板并使用。 它和 include 的主要区别就是 import 可以将变量封装到新的命名空间中。 例如：模板 /libs/commons.ftl 里面写了很多公共方法，想在其他模板里引用，只需要在其他模板的开头写上： 后续想使用/libs/commons.ftl 中的 copyright 方法，可以直接使用： assign 指令 assign 可以用来创建新的变量并为其赋值，语法如下： or or capture this or capture this 举例： myStr:${myStr} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/view-tech/freemarker.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-27 13:43:26 "},"web-dev/web-dev.html":{"url":"web-dev/web-dev.html","title":"实现 Web 开发","keywords":"","body":"Spring Boot 实现 Web 开发 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/web-dev/web-dev.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-23 18:25:51 "},"web-dev/integrate-mvc.html":{"url":"web-dev/integrate-mvc.html","title":"整合 MVC 和拦截器","keywords":"","body":"Spring Boot 整合 MVC 和拦截器 Spring Boot 整合 Spring MVC pom 依赖 org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web 自定义配置类 编写自定义配置类并实现WebMvcConfigurer package com.wukongnotnull.config; import com.wukongnotnull.interceptor.MyInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/login.html\").setViewName(\"login\"); } } login 页面展示 登录页面 用户名： 密码： Spring Boot 整合拦截器 自定义拦截器组件 准备主页（home.html）和 登录页（login.html） 拦截器实现未登录状态下，不能访问主页（home页面文件） package com.wukongnotnull.interceptor; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 拦截下来的请求，什么请求被阻止，什么请求被放行 Object username = request.getSession().getAttribute(\"userSession\"); if (username == null) { response.sendRedirect(request.getContextPath()+\"/login\"); // 拦截 return false; } // 放行 return true; } } 在 MyMvcConfig 配置类中添加拦截器的相关配置 package com.wukongnotnull.config; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.interceptor.MyInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/login\").setViewName(\"login\"); registry.addViewController(\"/home\").setViewName(\"home\"); } @Autowired private MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // 指定拦截哪些请求 // 拦截所有请求，除了 /login 和 /doLogin registry.addInterceptor(myInterceptor).addPathPatterns(\"/**\") .excludePathPatterns(\"/login\"); } } 测试 localhost:8080/home localhost:8080/login 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/web-dev/integrate-mvc.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-27 15:23:21 "},"web-dev/mvc-validation.html":{"url":"web-dev/mvc-validation.html","title":"数据校验 Validation","keywords":"","body":"Spring Boot 整合数据校验 Spring MVC 数据校验 前端提交表单数据，被后端接口接收到，为了程序的严谨性，后端会进行数据校验。 Spring Boot 通过 spring-boot-starter-validation 模块进行数据校验的工作。 JSR303/JSR-349 JSR303 是一项标准,只提供规范不提供实现，规定一些校验规范即校验注解，如 @Null ， @NotNull ， @Pattern ，位于javax.validation.constraints 包下。 JSR-349是其升级版本，添加了一些新特性。 Hibernate Validation： Hibernate Validation 是对这个规范的实现，并增加了一些其他校验注解，如@Email， @Length，@Range 等等 。 Spring Validation 对 Hibernate Validation 进行了二次封装，在 Spring MVC 模块中添加自动校验，并将校验信息封装进特定的类中。 使用案例 pom 依赖 org.springframework.boot spring-boot-starter-validation 前端页面 创建 registerUser.html 记得引入 spring-boot-starter-thymeleaf 依赖 用户名： 密码： User 实体类 属性上添加对应校验注解，比如 @NotBlank ，@Length ，@NotBlank 。 补充： @Data //记得引入 lombok 依赖 package com.wukongnotnull; //author: 悟空非空也（B站/知乎/公众号） import org.hibernate.validator.constraints.Length; import javax.validation.constraints.NotBlank; import java.io.Serializable; @Data //记得引入 lombok 依赖 public class User implements Serializable { private Integer id; @NotBlank(message = \"用户名不能为空\") private String username; @Length(min=3,max=10,message = \"密码长度为3-10之间\") @NotBlank(message = \"密码不能为空\") private String password; } controller 形参前添加 @Validated 或者 @Valid package com.wukongnotnull.controller; import com.wukongnotnull.User; import org.springframework.stereotype.Controller; import org.springframework.validation.BindingResult; import org.springframework.validation.annotation.Validated; import org.springframework.web.bind.annotation.*; import java.util.ArrayList; import java.util.List; //author: 悟空非空也（B站/知乎/公众号） @Controller public class UserController { @GetMapping(\"/register\") public String showRegisterPage(){ return \"registerUser\"; } // 添加注解 @Valid 或者 @Validated 均可以 // BindingResult 用于接收数据校验失败的提示信息 @PostMapping(value = \"/addUser\") @ResponseBody public Object addUser(@Validated User user , BindingResult bindingResult){ List list = new ArrayList<>(); if (bindingResult.hasErrors()) { bindingResult.getAllErrors().forEach(e ->{ list.add(e.getDefaultMessage()); }); }else { list.add(\"后端数据校验成功\"); } return list; } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/web-dev/mvc-validation.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-27 17:46:58 "},"web-dev/global-exception.html":{"url":"web-dev/global-exception.html","title":"全局异常处理","keywords":"","body":"Spring Boot 全局异常处理 Spring Boot 提供了对异常的全局性处理，相关注解如下: @ControllerAdvice 最常用的就是作为全局异常处理的切面类,同时通过该注解可以指定包扫描围。@ControllerAdvice 约定了几种可行的返回值，如果是直接返回 model 类的话，需要使用 @ResponseBody 进行 json 转换。 @ExceptionHandler 该注解在 Spring 3.X 版本引入，在处理异常时标注在方法级别，代表当前方法处理的异常类型有哪些。 案例 程序出现异常，如何被统一处理 ？ 返回响应信息封装类 package com.wukongnotnull.vo; import lombok.Data; //author: 悟空非空也（B站/知乎/公众号） // 响应信息的封装类 @Data public class ResultInfo { private Integer code; public String msg; private Object data; } 自定义全局异常处理器 package com.wukongnotnull.exception; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.utils.ParamsException; import com.wukongnotnull.vo.ResultInfo; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = {Exception.class}) @ResponseBody public ResultInfo handleException(Exception e){ ResultInfo resultInfo = new ResultInfo(); resultInfo.setCode(520); resultInfo.setMsg(\"系统异常\"); resultInfo.setData(e); return resultInfo; } } Controller @Controller public class UserController { @PostMapping(value = \"/ge\") @ResponseBody public Object testGlobalException() { ResultInfo resultInfo = new ResultInfo(); // 制造异常 int i = 1 / 0; resultInfo.setCode(521); resultInfo.setMsg(\"test 成功\"); resultInfo.setData(null); return resultInfo; } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/web-dev/global-exception.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-30 09:45:54 "},"web-dev/integrate-servlet.html":{"url":"web-dev/integrate-servlet.html","title":"整合 Servlet Filter Listener","keywords":"","body":"整合 Servlet Filter Listener 组件注册方式整合Servlet三大组件 3 大组件分别是 servlet filter 和 listener 整合 servlet 组件 servlet 负责和浏览器进行交互 ，接受请求，找到相对应的响应信息，返回给客户端（浏览器） myServlet package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.stereotype.Component; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @Component public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().write(\"hello MyServlet ,hello wukong\"); } } servletConfig package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.servlet.MyServlet; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class ServletConfig { // 注册Servlet组件 @Bean public ServletRegistrationBean getServlet(MyServlet myServlet){ return new ServletRegistrationBean<>(myServlet,\"/myServlet\"); } } 测试 通过路径找到对应的资源文件，返回给浏览器。 整合 filter 自定义 MyFilter package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.stereotype.Component; import javax.servlet.*; import java.io.IOException; @Component public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"悟空非空也在执行过滤操作。。。。\"); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } FilterConfig package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.servlet.MyFilter; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.Arrays; import java.util.Collections; @Configuration public class FilterConfig { // 注册filter组件 @Bean public FilterRegistrationBean getFilter(MyFilter myFilter){ FilterRegistrationBean myFilterFilterRegistrationBean = new FilterRegistrationBean<>(myFilter); myFilterFilterRegistrationBean.setUrlPatterns(Arrays.asList(\"/myServlet\")); return myFilterFilterRegistrationBean; } } 整合 listener MyListener package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.stereotype.Component; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; @Component public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"ServletContextListener 开始初始化.....\"); } @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(\"ServletContextListener 销毁掉.....\"); } } listenerConfig package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.servlet.MyListener; import org.springframework.boot.web.servlet.ServletListenerRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class ListenerConfig { @Bean public ServletListenerRegistrationBean getListener(MyListener myListener){ return new ServletListenerRegistrationBean<>(myListener); } } 路径扫描方式整合Servlet三大组件 启动类 添加注解 @ServletComponentScan @SpringBootApplication @ServletComponentScan public class WebappThymeleafApplication { public static void main(String[] args) { SpringApplication.run(WebappThymeleafApplication.class, args); } } myServlet 添加注解 @WebServlet(value = {\"/myServlet\"}) package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.stereotype.Component; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(value = {\"/myServlet\"}) public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().write(\"hello MyServlet ,hello wukong\"); } } myFilter 添加注解 @WebFilter(value = {\"/myServlet\"}) package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(value = {\"/myServlet\"}) public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"悟空非空也在执行过滤操作。。。。\"); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } myListener.java 添加注解 @WebListener package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; @WebListener public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"ServletContextListener 开始初始化.....\"); } @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(\"ServletContextListener 销毁掉.....\"); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/web-dev/integrate-servlet.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-27 22:04:25 "},"web-dev/file-upload.html":{"url":"web-dev/file-upload.html","title":"文件上传","keywords":"","body":"Spring Boot 多文件上传 controller package com.wukongnotnull.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.File; import java.io.IOException; import java.util.UUID; //author: 悟空非空也（B站/知乎/公众号） @Controller public class FileController { @GetMapping(\"/upload\") public String upload(){ return \"upload\"; } @PostMapping(\"/uploadFile\") public String uploadFile( @RequestParam(\"fileUpload\") MultipartFile[] uploadFiles, Model model, HttpServletRequest request){ for (MultipartFile file : uploadFiles) { String originalFilename = file.getOriginalFilename();// 获得文件名及后缀，例如 wukong.jpg //重新命名 String newFilename = UUID.randomUUID() +\"-\"+ originalFilename; // 创建上传文件的存放目录 :设置为tomcat服务器中的路径 String newPath = request.getServletContext().getRealPath(\"/upload\"); System.out.println(newPath); // String newPath =\"D:\\\\upload\"; File file1 = new File(newPath); if (!file1.exists()){ file1.mkdir(); } //创建新文件，接受传递过来的文件流 try { file.transferTo(new File(newPath,newFilename)); model.addAttribute(\"uploadStatus\",\"文件上传成功\"); } catch (IOException e) { e.printStackTrace(); model.addAttribute(\"uploadStatus\",\"上传失败\"); } } return \"upload\"; } } upload.html 动态添加文件上传列表 --> --> 上传成功 上传文件:&nbsp;&nbsp; // 动态添加上传按钮 function add(){ var innerdiv = \"\"; innerdiv += \"\" + \"\"; innerdiv +=\"\"; $(\"#file\").append(innerdiv); // 打开上传按钮 $(\"#submit\").css(\"display\",\"block\"); } // 删除当前行 function remove(obj) { $(obj).parent().remove(); if($(\"#file div\").length ==0){ $(\"#submit\").css(\"display\",\"none\"); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/web-dev/file-upload.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-30 14:34:49 "},"web-dev/file-download.html":{"url":"web-dev/file-download.html","title":"文件下载","keywords":"","body":"Spring Boot 文件下载 pom.xml commons-fileupload commons-fileupload 1.3.3 controller package com.wukongnotnull.controller; import org.apache.commons.io.FileUtils; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpStatus; import org.springframework.http.MediaType; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpServletRequest; import java.io.File; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; //author: 悟空非空也（B站/知乎/公众号） @Controller public class FileController { @GetMapping(\"/download\") public String downloadShow(){ return \"download\"; } @RequestMapping(\"/downloadFile\") public ResponseEntity getdownloadFile(String filename, HttpServletRequest request) { String dirPath= \"/Users/mac/Desktop/download/\"; File file = new File(dirPath, filename); HttpHeaders httpHeaders = new HttpHeaders(); // 通知浏览器以下载方式打开（下载前对文件名进行转码,处理中文名乱码问题） filename=this.getFilename(request,filename); httpHeaders.setContentDispositionFormData(\"attachment\" ,filename); httpHeaders.setContentType(MediaType.APPLICATION_OCTET_STREAM); ResponseEntity responseEntity =null; try { responseEntity = new ResponseEntity<>(FileUtils.readFileToByteArray(file), httpHeaders, HttpStatus.OK); } catch (IOException e) { responseEntity = new ResponseEntity<>(e.getMessage().getBytes(), HttpStatus.EXPECTATION_FAILED); e.printStackTrace(); } return responseEntity; } // 根据浏览器的不同进行编码设置，返回编码后的文件名 private String getFilename(HttpServletRequest request, String filename) { // IE不同版本User-Agent中出现的关键词 String[] IEBrowserKeyWords = {\"MSIE\", \"Trident\", \"Edge\"}; // 获取请求头代理信息 String userAgent = request.getHeader(\"User-Agent\"); String newFilename= null; try { for (String keyWord : IEBrowserKeyWords) { if (userAgent.contains(keyWord)) { //IE内核浏览器，统一为UTF-8编码显示，并对转换的+进行更正 return URLEncoder.encode(filename, \"UTF-8\").replace(\"+\",\" \"); } } newFilename = new String(filename.getBytes(\"UTF-8\"), \"ISO-8859-1\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } //火狐等其它浏览器统一为ISO-8859-1编码显示 return newFilename; } } html 文件下载 文件下载列表： wukong.rtf 下载文件 悟空.rtf 下载文件 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/web-dev/file-download.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-31 08:31:53 "},"web-dev/jar-package.html":{"url":"web-dev/jar-package.html","title":"jar 打包部署","keywords":"","body":"Spring Boot jar包方式打包部署 maven打包插件 org.springframework.boot spring-boot-maven-plugin 打包 步骤 ： + ---> command line: package 找到保存路径 运行jar包后直接访问 java -jar target\\myspringboot-mybatis-0.0.1-SNAPSHOT.jar 注意 使用 java 指令，需要配置java的环境变量 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/web-dev/jar-package.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-31 15:30:19 "},"web-dev/war-package.html":{"url":"web-dev/war-package.html","title":"war 打包部署","keywords":"","body":"Spring Boot war包方式打包部署 pom.xml war org.springframework.boot spring-boot-starter-tomcat provided 修改启动类 @SpringBootApplication public class MyspringbootMybatisApplication extends SpringBootServletInitializer { //继承SpringbootServletInitializer ,重写configure方法 protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(MyspringbootMybatisApplication.class); } public static void main(String[] args) { SpringApplication.run(MyspringbootMybatisApplication.class, args); } } 打包 配置 maven 命令 进行打包 操作 ： + -> Maven -> command Line: package 部署到外部的tomcat的webapp内 启动tomcat部署成功 执行 bin\\startup.bat指令 执行启动指令后，war 包指定解压，生成同名文件夹 浏览器访问 http:// localhost:8080/[同名文件夹] 注意 Jar 包内嵌服务器（Tomcat），war包不含服务器，需要外部服务器才能运行 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/web-dev/war-package.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-31 15:14:41 "},"fore-end-separation/fore-end-separation.html":{"url":"fore-end-separation/fore-end-separation.html","title":"前后端分离","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/fore-end-separation/fore-end-separation.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"fore-end-separation/interface-design.html":{"url":"fore-end-separation/interface-design.html","title":"RestFull 接口设计","keywords":"","body":" RestFull 接口设计 RESTfull API 设计思想 最近，流行的Web都分为前端和后端两个部分。前端设备各种各样（手机、平板、桌面电脑等等.）。因此，需要一种统一的机制，方便不同的前端设备与后端进行通信。 需要一个良好的API构架来解决这样问题。RESTful API 是目前比较成熟的一套API设计理论。 协议 API与前端设备的通信协议，使用 HTTPs 协议。 域名 应该尽量将API部署在专用域名之下。 https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 https://example.org/api/ 版本 可以将 API 的版本号放入 URL 中，如 Github 。 https://api.example.com/v1/ 路径 路径表示 API 的具体地址。 在 RESTful 架构中，每个网址代表一种资源（resource），规定网址中不能有动词，只能有名词。 名词一般与数据库的表格名对应。 名词需要使用复数。 比如，有一个电商系统，它的路径应该如下设计。 https://api.example.com/v1/users https://api.example.com/v1/bills https://api.example.com/v1/products HTTP动词 对于资源的具体操作类型，由HTTP动词表示。 常用的 HTTP 动词有如下五个种（括号里是对应的SQL命令）。 GET（SELECT）： 从服务器取出资源（一项或多项）。 POST（CREATE）： 在服务器新建一个资源。 PUT（UPDATE）： 在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 还有两个不常用的HTTP动词。 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 举例： GET /users：查询用户列表 POST /users： 新建一个用户信息 GET /users/ID：获取某个指定id 的用户信息 PUT /users/ID：更新某个指定id 的用户的信息（提供该用户的全部信息） PATCH /users/ID：更新某个指定id 的用户的信息（提供该用户的部分信息） DELETE /users/ID：删除指定用户 GET /users/ID/bills：列出某个用户的所有订单 DELETE /users/ID/bills/ID：删除某个指定用户的指定订单 过滤信息 若查询记录数量很多，服务器不可能都将它们返回给客户端。API应该提供参数，过滤返回结果。 下面是一些常见的参数。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?users_type_id=1：指定筛选条件 状态码 服务器向浏览器返回的状态码和提示信息，常见如下 200 OK - [GET]： 服务器成功返回用户请求的数据，该操作是每次都成功。 201 CREATED - [POST/PUT/PATCH]： 用户新建或修改数据成功。 202 Accepted - [*]： 表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]： 用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，每次都是一样 401 Unauthorized - [*]： 表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]： 用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]： 用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]： 用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]： 服务器发生错误，用户将无法判断发出的请求是否成功。 返回结果 针对不同操作，服务器向用户返回的结果应该符合以下规范 GET /collection： 返回资源对象的列表（数组） GET /collection/resource： 返回单个资源对象 POST /collection： 返回新生成的资源对象 PUT /collection/resource： 返回完整的资源对象 PATCH /collection/resource： 返回完整的资源对象 DELETE /collection/resource： 返回一个空文档 RESTfull API 设计实操 测试前后端分离的项目，浏览器是不能胜任的，这里选择常用的测试工具，PostMan 完成接口测试。 @RequestMapping 该注解可以加到方法上或者是类上，设置请求映射规则。 指定请求路径 path或者value属性都可以用来指定请求路径。 @RestController @RequestMapping(\"/test\") public class HelloController { @RequestMapping(\"/testPath\") public String testPath(){ return \"testPath\"; } } @RestController public class HelloController { @RequestMapping(\"/test/testPath\") public String testPath(){ return \"testPath\"; } } 指定请求方式 method属性可以用来指定可处理的请求方式。 注意：可以运用如下注解来进行替换 ​ @PostMapping 等价于 @RequestMapping(method = RequestMethod.POST) ​ @GetMapping 等价于 @RequestMapping(method = RequestMethod.GET) ​ @PutMapping 等价于 @RequestMapping(method = RequestMethod.PUT) ​ @DeleteMapping 等价于 @RequestMapping(method = RequestMethod.DELETE) @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testMethod\",method = RequestMethod.POST) public String testMethod(){ System.out.println(\"testMethod处理请求\"); return \"testMethod\"; } } 指定请求参数 我们可以使用params属性来对请求参数进行一些限制。可以要求必须具有某些参数，或者是某些参数必须是某个值，或者是某些参数必须不是某个值。 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testParams\",method = RequestMethod.GET,params = \"code\") public String testParams(){ System.out.println(\"testParams处理了请求\"); return \"testParams\"; } } ​ 如果是要求不能有code这个参数可以把改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testParams\",method = RequestMethod.GET,params = \"!code\") public String testParams(){ System.out.println(\"testParams处理请求\"); return \"testParams\"; } } ​ 如果要求有code这参数，并且这参数值必须是某个值可以改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testParams\",method = RequestMethod.GET,params = \"code=wukong\") public String testParams(){ System.out.println(\"testParams处理请求\"); return \"testParams\"; } } 如果要求有code这参数，并且这参数值必须不是某个值可以改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testParams\",method = RequestMethod.GET,params = \"code!=wukong\") public String testParams(){ System.out.println(\"testParams处理了请求\"); return \"testParams\"; } } 指定请求头 使用 headers 属性来对请求头进行一些限制。 例如，请求头中有 deviceType 能够被方法处理。 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testHeaders\",method = RequestMethod.GET,headers = \"deviceType\") public String testHeaders(){ System.out.println(\"testHeaders处理了请求\"); return \"testHeaders\"; } } 要求不能有deviceType这个请求头，可以写成如下代码 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testHeaders\",method = RequestMethod.GET,headers = \"!deviceType\") public String testHeaders(){ System.out.println(\"testHeaders处理了请求\"); return \"testHeaders\"; } } 如果要求有deviceType这个请求头，并且其值必须是某个值可以改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testHeaders\",method = RequestMethod.GET,headers = \"deviceType=ios\") public String testHeaders(){ System.out.println(\"testHeaders处理请求\"); return \"testHeaders\"; } } 如果要求有deviceType这个请求头，并且其值必须不是某个值可以改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testHeaders\",method = RequestMethod.GET,headers = \"deviceType!=ios\") public String testHeaders(){ System.out.println(\"testHeaders处理了请求\"); return \"testHeaders\"; } } 指定请求头Content-Type 使用 consumes 属性来对 Content-Type 这个请求头进行一些限制。 指定请求头中的Content-Type必须为 multipart/from-data ，代码如下 @RequestMapping(value = \"/testConsumes\",method = RequestMethod.POST,consumes = \"multipart/from-data\") public String testConsumes(){ System.out.println(\"testConsumes处理了请求\"); return \"testConsumes\"; } 要求请求头Content-Type的值必须不能为某个multipart/from-data则可以改成如下形式： @RequestMapping(value = \"/testConsumes\",method = RequestMethod.POST,consumes = \"!multipart/from-data\") public String testConsumes(){ System.out.println(\"testConsumes处理了请求\"); return \"testConsumes\"; } @PathVariable 获取请求参数 该接口可以用来根据id查询用户。请求路径要求为 /user ，请求方式要求为GET。 @RestController public class UserController { @RequestMapping(value = \"/user/{id}\",method = RequestMethod.GET) public String findUserById( @PathVariable(\"id\")Integer id){ System.out.println(id); return \"findUserById\"; } } 根据id和username查询用户。请求路径要求为 /user ，请求方式要求为GET。 @RestController public class UserController { @RequestMapping(value = \"/user/{id}/{name}\",method = RequestMethod.GET) public String findUser(@PathVariable(\"id\") Integer id,@PathVariable(\"name\") String name){ System.out.println(id); System.out.println(name); return \"findUser\"; } } @RequestBody 获得请求体中的 json 参数 使用@RequestBody注解获取请求体中的数据。 SpringBoot的web启动器已经默认导入了jackson的依赖，不需要再额外导入。 注意事项 使用@RequestBody来获取请求体中 Json 数据，并且进行转换，要求请求头 Content-Type 的值必须为 application/json 。 请求体中数据 {\"name\":\"wukongnotnull\",\"age\":18} User 实体 @Data @NoArgsConstructor @AllArgsConstructor public class User { private Integer id; private String name; private Integer age; } ​ 获取参数封装成实体对象 如果我们想把Json数据获取出来封装User对象,我们可以这样定义方法： @RestController public class UserController { @RequestMapping(value = \"/user\",method = RequestMethod.POST) public String insertUser(@RequestBody User user){ System.out.println(user); return \"insertUser\"; } } 或者， 获取参数封装成 Map 集合 @RequestMapping(value = \"/user\",method = RequestMethod.POST) public String insertUser(@RequestBody Map map){ System.out.println(map); return \"insertUser\"; } 请求体中参数为集合 请求体中数据 [{\"name\":\"悟空\",\"age\":100},{\"name\":\"猪八戒\",\"age\":200},{\"name\":\"唐僧\",\"age\":30}] 方法定义 @RequestMapping(value = \"/users\",method = RequestMethod.POST) public String insertUsers(@RequestBody List users){ System.out.println(\"insertUsers\"); System.out.println(users); return \"insertUser\"; } @RequestParam 获取 QueryString 格式参数 QueryString 格式参数为 http://localhost:8080/testRequestParam?id=1&name=wukongnotnull&likes=eat&likes=drink&likes=play 各个参数单独获取 方法中参数名和请求参数名一致时，可以省略 **@RequestParam** 注解。 @RequestMapping(\"/testRequestParam\") public String testRquestParam(Integer id, String name, String[] likes){ System.out.println(\"testRquestParam\"); System.out.println(id); System.out.println(name); System.out.println(Arrays.toString(likes)); return \"testRquestParam\"; } 方法中参数名和请求参数名一致时，需要添加 **@RequestParam** 注解。 @RequestMapping(\"/testRequestParam\") public String testRquestParam(@RequestParam(\"id\") Integer uid,@RequestParam(\"name\") String uname, @RequestParam(\"likes\")String[] ulikes){ System.out.println(uid); System.out.println(name); System.out.println(Arrays.toString(likes)); return \"testRquestParam\"; } 获取参数封装成实体对象 把这些参数封装到 User 对象中。 User 实体 实体类中的成员变量名要和请求参数名一致，并且要提供对应的set/get方法。 @Data @NoArgsConstructor @AllArgsConstructor public class User { private Integer id; private String name; private Integer age; private String[] likes; } ​ Controller @RequestMapping(\"/testRequestParam\") public String testRquestParam(User user){ System.out.println(\"testRquestParam\"); System.out.println(user); return \"testRquestParam\"; } 测试 url http://localhost:8080/testRequestParam?id=1&name=wukongnotnull&likes=eat&likes=drink&likes=play 相关注解其他属性 required ​ 代表是否必须，默认值为true也就是必须要有对应的参数。如果没有就会报错。 ​ 如果对应的参数可传可不传则可以把其设置为fasle 例如： @RequestMapping(\"/testRquestParam\") public String testRquestParam(@RequestParam(value = \"id\",required = false) Integer uid,@RequestParam(\"name\") String name, @RequestParam(\"likes\")String[] likes){ System.out.println(\"testRquestParam\"); System.out.println(uid); System.out.println(name); System.out.println(Arrays.toString(likes)); return \"testRquestParam\"; } defaultValue ​ 如果对应的参数没有，我们可以用defaultValue属性设置默认值。 例如： @RequestMapping(\"/testRquestParam\") public String testRquestParam(@RequestParam(value = \"id\",required = false,defaultValue = \"777\") Integer uid,@RequestParam(\"name\") String name, @RequestParam(\"likes\")String[] likes){ System.out.println(\"testRquestParam\"); System.out.println(uid); System.out.println(name); System.out.println(Arrays.toString(likes)); return \"testRquestParam\"; } @ResponseBody RestFul 风格请求，把返回数据转换成 Json ，放入响应体中。 @Controller @RequestMapping(\"/response\") public class ResponseController { @RequestMapping(\"/user/{id}\") @ResponseBody public User findById(@PathVariable(\"id\") Integer id){ User user = new User(); return user; } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/fore-end-separation/interface-design.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-01 00:09:39 "},"fore-end-separation/response-result.html":{"url":"fore-end-separation/response-result.html","title":"统一响应结果的设计","keywords":"","body":" 响应结果统一设计 背景 在分布式、微服务盛行的时代，项目都采用的微服务框架和前后端分离方式。 前端和后端进行交互，前端按照约定请求 URL 路径，并携带相关请求参数；后端服务器接收请求，进行业务处理，返回数据给前端。 统一接口的返回数据，变得非常重要。 统一格式设计 一般形式 { # 是否响应成功 success: true, # 响应状态码 code: 200, # 响应数据 data: Object # 返回错误信息 message: \"\", } 结果类枚举 public enum ResultCodeEnum { /*** 通用部分 100 - 599***/ // 成功请求 SUCCESS(200, \"successful\"), // 重定向 REDIRECT(301, \"redirect\"), // 资源未找到 NOT_FOUND(404, \"not found\"), // 服务器错误 SERVER_ERROR(500,\"server error\"); //可以根据不同模块用不同的区级分开错误码 // 1000～1999 区间表示用户模块错误 // 2000～2999 区间表示订单模块错误 // 3000～3999 区间表示商品模块错误 /** * 响应状态码 */ private Integer code; /** * 响应信息 */ private String message; ResultCodeEnum(Integer code, String msg) { this.code = code; this.message = msg; } public Integer getCode() { return code; } public String getMessage() { return message; } } 统一结果类 public class HttpResult implements Serializable { /** * 是否响应成功 */ private Boolean success; /** * 响应状态码 */ private Integer code; /** * 响应数据 */ private T data; /** * 错误信息 */ private String message; // 构造器开始 /** * 无参构造器(构造器私有，外部不可以直接创建) */ private HttpResult() { this.code = 200; this.success = true; } /** * 有参构造器 * @param obj */ private HttpResult(T obj) { this.code = 200; this.data = obj; this.success = true; } /** * 有参构造器 * @param resultCode */ private HttpResult(ResultCodeEnum resultCode) { this.success = false; this.code = resultCode.getCode(); this.message = resultCode.getMessage(); } // 构造器结束 /** * 通用返回成功（没有返回结果） * @param * @return */ public static HttpResult success(){ return new HttpResult(); } /** * 返回成功（有返回结果） * @param data * @param * @return */ public static HttpResult success(T data){ return new HttpResult(data); } /** * 通用返回失败 * @param resultCode * @param * @return */ public static HttpResult failure(ResultCodeEnum resultCode){ return new HttpResult(resultCode); } public Boolean getSuccess() { return success; } public void setSuccess(Boolean success) { this.success = success; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public T getData() { return data; } public void setData(T data) { this.data = data; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } @Override public String toString() { return \"HttpResult{\" + \"success=\" + success + \", code=\" + code + \", data=\" + data + \", message='\" + message + '\\'' + '}'; } } 说明： 构造器私有，外部不可以直接创建； 只可以调用统一返回类的静态方法返回对象； success 是一个Boolean 值，通过这个值，可以直接观察到该次请求是否成功； data 表示响应数据，用于请求成功后，返回客户端需要的数据。 测试 @RestController public class HttpRestController { @GetMapping(\"/success\") public HttpResult success(){ return HttpResult.success(); } @GetMapping(\"/successWithData\") public HttpResult successWithData(){ return HttpResult.success(\"我是悟空非空也\"); } @GetMapping(\"/failure\") public HttpResult failure(){ return HttpResult.failure(ResultCodeEnum.NOT_FOUND); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/fore-end-separation/response-result.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-01 00:09:39 "},"fore-end-separation/user-management.html":{"url":"fore-end-separation/user-management.html","title":"用户模块管理 CRUD","keywords":"","body":" 用户模块管理 准备工作 集成mybatis springboot 2.x 默认数据源是 Hikari 引入坐标 org.springframework.boot spring-boot-starter-web org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.4 com.github.pagehelper pagehelper-spring-boot-starter 1.2.13 mysql mysql-connector-java application.yml # sb2.x 默认数据源Hikari配置 spring: datasource: url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf8&serverTimezone=GMT%2B8 username: root password: rootroot driver-class-name: com.mysql.cj.jdbc.Driver # mybatis 配置 mybatis: mapper-locations: classpath:/mappers/*.xml configuration: map-underscore-to-camel-case: true type-aliases-package: com.wukongnotnull.domain #分页插件配置 pagehelper: helper-dialect: mysql 启动类 @SpringBootApplication public class App { public static void main( String[] args ) { SpringApplication.run(App.class); System.out.println( \"Hello World!\" ); } } Sql 脚本 create database `test`; use `test`; CREATE TABLE `user` ( `id` INT(20) NOT NULL AUTO_INCREMENT COMMENT '用户 id', `username` VARCHAR(200) DEFAULT NULL COMMENT '用户名', `password` VARCHAR(200) DEFAULT NULL COMMENT '密码', PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; insert into `user`(`username`,`password`) value ('wukong','wukong'); insert into `user`(`username`,`password`) value ('zhubajie','zhubajie'); insert into `user`(`username`,`password`) value ('shaseng','shaseng'); insert into `user`(`username`,`password`) value ('bailongma','bailongma'); select * from user; User 实体类 package com.wukongnotnull.domain; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; //author: 悟空非空也（B站/知乎/公众号） @Data @NoArgsConstructor @AllArgsConstructor public class User { private Integer id; private String username; private String password; } 设计统一结果类 package com.wukongnotnull.vo; import lombok.Data; import java.io.Serializable; //author: 悟空非空也（B站/知乎/公众号） public class HttpResult implements Serializable { /** * 是否响应成功 */ private Boolean success; /** * 响应状态码 */ private Integer code; /** * 响应数据 */ private T data; /** * 错误信息 */ private String message; // 响应成功的时候，new 的对象 private HttpResult() { this.code=200; this.success = true; } // 响应成功，不携带Data public static HttpResult success(){ return new HttpResult(); } // 响应成功时的构造器 private HttpResult(T data){ this.code=200; this.success = true; this.data = data; } // 响应成功，携带Data public static HttpResult success(T data){ return new HttpResult(data); } // 响应失败的时候的构造器 private HttpResult(ResultCodeEnum resultCode){ this.success = false; this.code=resultCode.getCode() ; this.message= resultCode.getMessage(); } // 响应失败时，如何创建实例 public static HttpResult failure(ResultCodeEnum resultCode){ return new HttpResult(resultCode); } public Boolean getSuccess() { return success; } public void setSuccess(Boolean success) { this.success = success; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public T getData() { return data; } public void setData(T data) { this.data = data; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } @Override public String toString() { return \"HttpResult{\" + \"success=\" + success + \", code=\" + code + \", data=\" + data + \", message='\" + message + '\\'' + '}'; } } package com.wukongnotnull.vo; //author: 悟空非空也（B站/知乎/公众号） // 响应错误（失败）的信息封装枚举 public enum ResultCodeEnum { // 服务器错误 SERVER_ERROR(500,\"server error\"), // 重定向 REDIRECT(301, \"redirect\"), NOT_FOUND(404,\"not found\"), USERNAME_REPEAT(520,\"username repeat\"), WUKONG_ERROR(1314,\" unkown error\") // 自定义错误提示 ; /** * 响应状态码 */ private Integer code; /** * 响应信息 */ private String message; ResultCodeEnum(Integer code, String message) { this.code = code; this.message = message; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } } 自定义异常工具类 自定义 ParamsException 异常类 作用： 自定义异常，遇到用户名重复等属性错误时，抛出异常。 package com.wukongnotnull.utils; /** * author: 悟空非空也（B站/知乎/公众号） */ public class ParamsException extends RuntimeException { // 自定义异常类型码 private Integer type = 300; // 自定义异常的说明信息 private String msg = \"默认自定义异常类型\"; public ParamsException(){ super(); } public ParamsException(Integer type){ this.type = type; } public ParamsException(String msg) { this.msg = msg; } public ParamsException(Integer type, String msg) { this.type = type; this.msg = msg; } public Integer getType() { return type; } public void setType(Integer type) { this.type = type; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } } AssertUtil 提示语工具类，用于显示不同情况下，返回不同的提示语 package com.wukongnotnull.utils; /** * author: 悟空非空也（B站/知乎/公众号） */ /** * 提示语工具类 */ public class AssertUtil { public static void isTrue(boolean flag, Integer code, String message) { if (flag) { throw new ParamsException(code, message); } System.out.println(); } } 需求： 根据用户名查询指定用户 业务规定：user表中 id 和 username 都要求唯一性 mapper 层接口 com.wukongnotnull.mapper.UserMapper package com.wukongnotnull.mapper; import com.wukongnotnull.domain.User; public interface UserMapper { public User getUserByUsername(String username); } sql映射文件 resources/mappers/UserMapper.xml select * from user where username = #{username} Service public interface UserService { public User getUserByUsername(String username); } ------------分割线------------------ @Service public class UserServiceImpl implements UserService { @Autowired private UserMapper userMapper; @Override public User getUserByUsername(String username) { return this.userMapper.getUserByUsername(username); } } Controller package com.wukongnotnull.controller; import com.wukongnotnull.domain.User; import com.wukongnotnull.service.UserService; import com.wukongnotnull.vo.HttpResult; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/api/v1\") public class UserController { @Autowired private UserService userService; @GetMapping(\"/users/{username}\") public HttpResult getUserByUsername(@PathVariable String username){ User userByUsername = this.userService.getUserByUsername(username); return HttpResult.success(userByUsername); } } 需求： 根据id查询指定用户 上述需求和本需求都是get请求方式，要留意请求路径的区分，不然会报错 controller package com.wukongnotnull.controller; import com.wukongnotnull.domain.User; import com.wukongnotnull.service.UserService; import com.wukongnotnull.vo.HttpResult; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/api/v1\") public class UserController { @Autowired private UserService userService; @GetMapping(\"/users/{username}\") public HttpResult getUserByUsername(@PathVariable String username){ User userByUsername = this.userService.getUserByUsername(username); return HttpResult.success(userByUsername); } @GetMapping(\"/users/id/{id}\") public HttpResult getUserById(@PathVariable(\"id\") Integer id){ User user =this.userService.getUserById(id); return HttpResult.success(user); } } service User getUserById(Integer id); -------- 分割线---------- @Override public User getUserById(Integer id) { return this.userMapper.getUserById(id); mapper User getUserById(@Param(\"id\") Integer id); -------- 分割线---------- select * from user where id = #{id} 需求： 添加用户 业务要求： 添加用户的所有字段为非空 ：通过后端数据校验（ @NotBlank 注解） 用户名不能重复 ：自定义异常类来实现 mapper & sql 映射文件 public interface UserMapper { public int addUser(User user); } insert into user (username, password) values (#{username}, #{password}) service public User addUser(User user); @Override public User getUserByUsername(String username) { return this.userMapper.getUserByUsername(username); } /** * 字段非空判断 * username 不能重复 */ public User addUser(User user) { AssertUtil.isTrue(userMapper.getUserByUsername(user.getUsername()) !=null,520,\"用户名重复，请重新输入\"); User user1 = null; int i = userMapper.addUser(user); if(i == 1){ // 添加成功 user1 = this.getUserByUsername(user.getUsername()); }else { // 添加失败 System.out.println(\"用户添加失败\"); } return user1; } controller @PostMapping(\"/users\") public HttpResult addUser(@RequestBody User user){ HttpResult httpResult =null; try { User user1 = this.userService.addUser(user); httpResult = HttpResult.success(user1); }catch (ParamsException paramsException){ if(paramsException.getCode() == 520){ httpResult = HttpResult.failure(ResultCodeEnum.USERNAME_REPEAT); } }catch (Exception e){ httpResult = HttpResult.failure(ResultCodeEnum.WUKONG_ERROR); e.printStackTrace(); } return httpResult; } 需求： 修改用户 业务要求： 所有字段不能为空。 （Validation 后端数据校验） username 字段 修改后的新名字，不可以同原名； 同时，不能同其他用户信息的用户名。 dao & sql 映射文件 int modifyUser(User user); update user set username = #{username}, password = #{password} where id = #{id} service User modifyUser(User user); @Override public User modifyUser(User user) { //username 不能已存在，除了自己 User userByUsername = this.userMapper.getUserByUsername(user.getUsername()); AssertUtil.isTrue(userByUsername != null && user.getId().equals(userByUsername.getId()),520,\"用户名重复，请重新输入\"); //修改用户信息 int i = userMapper.modifyUser(user); return this.getUserByUsername(user.getUsername()); } controller @PutMapping(\"/users\") public HttpResult modifyUser(@RequestBody User user){ HttpResult httpResult =null; try { User user1 = this.userService.modifyUser(user); httpResult = HttpResult.success(user1); }catch (ParamsException paramsException){ if(paramsException.getCode() == 520){ httpResult = HttpResult.failure(ResultCodeEnum.USERNAME_REPEAT); } }catch (Exception e){ httpResult = HttpResult.failure(ResultCodeEnum.WUKONG_ERROR); e.printStackTrace(); } return httpResult; } 需求：全局异常处理 自定义全局异常处理器 package com.wukongnotnull.exception; import com.wukongnotnull.utils.ParamsException; import com.wukongnotnull.vo.HttpResult; import com.wukongnotnull.vo.ResultCodeEnum; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; //author: 悟空非空也（B站/知乎/公众号） @ControllerAdvice public class GlobalExceptionHandler { @ResponseBody @ExceptionHandler(value = {Exception.class}) public HttpResult handleGlobalException(Exception e){ HttpResult httpResult = null; if(e instanceof ParamsException){ ParamsException paramsException = (ParamsException) e; if(paramsException.getCode() == 520){ httpResult = HttpResult.failure(ResultCodeEnum.USERNAME_REPEAT); } }else{ httpResult = HttpResult.failure(ResultCodeEnum.WUKONG_ERROR); e.printStackTrace(); } return httpResult; } } 修改 controller 中方法 @PostMapping(\"/users\") public HttpResult addUser(@Validated @RequestBody User user){ User user1 = this.userService.addUser(user); return HttpResult.success(user1); } @PutMapping(\"/users\") public HttpResult modifyUser(@RequestBody User user){ User user1 = this.userService.modifyUser(user); return HttpResult.success(user1); } 需求： 删除用户 dao & sql 映射语句 int deleteUser(Integer id); delete from user where id = #{id} service void deleteUser(Integer id); --------------分割线------------------- public void deleteUser(Integer id) { //是否存在该用户 User userById = this.getUserById(id); //删除用户 if(userById != null) { this.userMapper.deleteUser(id); }else { System.out.println(\"删除此用户时，发现该用户不存在！！\"); } controller @DeleteMapping(\"/users/{id}\") public HttpResult deleteUser(@PathVariable Integer id) { this.userService.deleteUser(id); return HttpResult.success(); } 需求： 根据用户名查询用户分页列表 坐标 com.github.pagehelper pagehelper-spring-boot-starter 1.2.13 application.yml #分页插件配置 pagehelper: helper-dialect: mysql bo/UserParams 实体类 根据用户名查询，将查询参数，封装成一个自定义业务对象 bo: business object package com.wukongnotnull.bo; /* author: 悟空非空也（B站/知乎/公众号） */ public class UserParams { private Integer pageNum = 1; //当前页 private Integer pageSize = 3; //页容量（每页包含多少记录） private String username; public Integer getPageNum() { return pageNum; } public void setPageNum(Integer pageNum) { this.pageNum = pageNum; } public Integer getPageSize() { return pageSize; } public void setPageSize(Integer pageSize) { this.pageSize = pageSize; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } dao & sql 映射文件 List getUserList(UserParams userParams); select * from user and username like CONCAT('%',#{username},'%') service PageInfo getUserPageList(UserParams userParams); public PageInfo getUserPageList(UserParams userParams) { PageHelper.startPage(userParams.getPageNum(), userParams.getPageSize()); return new PageInfo(this.userMapper.getUserList(userParams)); } controller @GetMapping(\"/users\") public HttpResult getUserPageList(@RequestBody UserParams userParams){ PageInfo userPageList = this.userService.getUserPageList(userParams); return HttpResult.success(userPageList); } postman 测试 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/fore-end-separation/user-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-03 09:49:37 "},"Integrated-swagger/integrated-swagger.html":{"url":"Integrated-swagger/integrated-swagger.html","title":"Api文档框架 Swagger","keywords":"","body":" API 文档框架 Swagger2 Swagger2 文档构建工具 前后端分离的开发模式中，前端开发者和后端开发者需要及时地沟通 RESTful API 接口约定，非常耗时费力。 这里借助第三方构建工具 Swagger2 来实现Api文档生成功能 。 这样减少彼此的沟通成本。 引入依赖 io.springfox springfox-swagger2 2.9.2 io.springfox springfox-swagger-ui 2.9.2 配置类 package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; import java.util.ArrayList; @Configuration @EnableSwagger2 public class Swagger2Config { @Bean public Docket createDocket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(this.apiInfo()) .select() //根据基包路径选择接口 .apis(RequestHandlerSelectors.basePackage(\"com.wukongnotnull.controller\")) .build(); } //配置文档信息 private ApiInfo apiInfo() { Contact contact = new Contact(\"悟空非空也\", \"https://wukongnotnull.com\", \"1390128154@qq.com\"); return new ApiInfo( \"悟空的项目api文档\", // 标题 \"实现对用户模块的增删改查\", // 描述 \"v1.0\", // 版本 \"http://terms.service.url/组织链接\", // 组织链接 contact, // 联系人信息 \"Apach 2.0 许可\", // 许可 \"许可链接\", // 许可连接 new ArrayList<>()// 扩展 ); } } // 根据包路径选择接口 basePackage(final String basePackage) // 选择所有接口 any() // 不选择接口 none() // 根据 method 的注解选择，如 withMethodAnnotation(GetMapping.class) 只扫描 GET 请求 withMethodAnnotation(final Class annotation) // 根据类上的注解选择，如.withClassAnnotation(Controller.class)只选择 controller注解类中的接口 withClassAnnotation(final Class annotation) 访问路径 wukong 为项目名 http://localhost:8081/wukong/swagger-ui.html controller package com.wukongnotnull.controller; import com.github.pagehelper.PageInfo; import com.wukongnotnull.bo.UserParams; import com.wukongnotnull.domain.User; import com.wukongnotnull.service.UserService; import com.wukongnotnull.vo.HttpResult; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.validation.annotation.Validated; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping(\"/api/v1\") @Api(tags = \"用户模块控制器\") public class UserController { @Autowired private UserService userService; @GetMapping(\"/users/{username}\") @ApiOperation(value =\"getUserByUsername接口\",notes = \"根据用户名查询用户\") @ApiImplicitParam( name = \"username\", value = \"用户名\", required = true, dataType = \"String\", defaultValue = \"默认值是。。。\", paramType = \"path\" ) public HttpResult getUserByUsername(@PathVariable String username){ User userByUsername = this.userService.getUserByUsername(username); return HttpResult.success(userByUsername); } @GetMapping(\"/users/id/{id}\") @ApiOperation(value = \"getUserById接口\", notes = \"根据id查询用户\") @ApiImplicitParam( name = \"id\", value = \"用户id字段\", required = true,dataType = \"int\", paramType = \"path\",defaultValue = \"1\" ) public HttpResult getUserById(@PathVariable(\"id\") Integer id){ User user =this.userService.getUserById(id); return HttpResult.success(user); } @PostMapping(\"/users\") @ApiOperation(value = \"添加用户接口\", notes = \"实现添加用户的功能（详细一点）\") @ApiImplicitParam( name = \"user\", value = \"User对象\", dataType = \"User\", paramType = \"body\", defaultValue = \"默认值...\" ) public HttpResult addUser(@Validated @RequestBody User user){ User user1 = this.userService.addUser(user); return HttpResult.success(user1); } @PutMapping(\"/users\") @ApiOperation(value = \"modifyUser接口\", notes = \"实现用户信息的修改\") @ApiImplicitParam( name = \"user\",value = \"User对象\",required = true, dataType = \"User\",paramType = \"body\", defaultValue = \"默认值为...\" ) public HttpResult modifyUser(@RequestBody User user){ User user1 = this.userService.modifyUser(user); return HttpResult.success(user1); } @DeleteMapping(\"/users/{id}\") @ApiOperation(value = \"deleteUser接口\", notes = \"删除用户的功能\") @ApiImplicitParam( name = \"id\",value = \"用户id\", defaultValue = \"1\", required = true, dataType = \"int\",paramType = \"path\" ) public HttpResult deleteUser(@PathVariable Integer id) { this.userService.deleteUser(id); return HttpResult.success(); } @GetMapping(\"/users\") @ApiOperation(value = \"getUserPageList接口\", notes = \"分页查询用户列表\") @ApiImplicitParam( name = \"userParams\", value = \"业务自定义对象\", required = true,dataType = \"UserParams\", paramType = \"body\" ) public HttpResult getUserPageList(@RequestBody UserParams userParams){ PageInfo userPageList = this.userService.getUserPageList(userParams); return HttpResult.success(userPageList); } } model User package com.wukongnotnull.pojo; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; @ApiModel(description = \"User实体类\") public class User { // 当类型为Integer类型时候, example 必须要写 @ApiModelProperty(name = \"id\",value = \"用户id\",example = \"1\") private Integer id; @ApiModelProperty(name = \"username\",value = \"用户名\") private String username; @ApiModelProperty(name = \"password\",value = \"用户密码\") private String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } HttpResult package com.wukongnotnull.vo; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import java.io.Serializable; //author: 悟空非空也（B站/知乎/公众号） @ApiModel(description = \"统一响应信息类\") public class HttpResult implements Serializable { /** * 是否响应成功 */ @ApiModelProperty(name = \"success\",value = \"是否响应成功\") private Boolean success; /** * 响应状态码 */ @ApiModelProperty(name = \"code\",value = \"状态码\",example = \"200\") private Integer code; /** * 响应数据 */ @ApiModelProperty(name = \"data\",value = \"响应数据\") private T data; /** * 错误信息 */ @ApiModelProperty(name = \"message\",value = \"错误提示信息\") private String message; // 响应成功的时候，new 的对象 private HttpResult() { this.code=200; this.success = true; } // 响应成功，不携带Data public static HttpResult success(){ return new HttpResult(); } // 响应成功时的构造器 private HttpResult(T data){ this.code=200; this.success = true; this.data = data; } // 响应成功，携带Data public static HttpResult success(T data){ return new HttpResult(data); } // 响应失败的时候的构造器 private HttpResult(ResultCodeEnum resultCode){ this.success = false; this.code=resultCode.getCode() ; this.message= resultCode.getMessage(); } // 响应失败时，如何创建实例 public static HttpResult failure(ResultCodeEnum resultCode){ return new HttpResult(resultCode); } public Boolean getSuccess() { return success; } public void setSuccess(Boolean success) { this.success = success; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public T getData() { return data; } public void setData(T data) { this.data = data; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } @Override public String toString() { return \"HttpResult{\" + \"success=\" + success + \", code=\" + code + \", data=\" + data + \", message='\" + message + '\\'' + '}'; } } UserParams package com.wukongnotnull.bo; /* author: 悟空非空也（B站/知乎/公众号） */ import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; @ApiModel(description = \"业务所需用户参数封装类\") public class UserParams { @ApiModelProperty(name = \"pageNum\",value = \"当前页码\",example = \"1\") private Integer pageNum = 1; //当前页 @ApiModelProperty(name = \"pageSize\",value = \"状态码\",example = \"3\") private Integer pageSize = 3; //页容量（每页包含多少记录） @ApiModelProperty(name = \"username\",value = \"用户名\") private String username; public Integer getPageNum() { return pageNum; } public void setPageNum(Integer pageNum) { this.pageNum = pageNum; } public Integer getPageSize() { return pageSize; } public void setPageSize(Integer pageSize) { this.pageSize = pageSize; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } 分环境显示文档 动态配置当项目处于test、dev环境时,显示swagger; 处于prod时不显示swagger 文档 import org.springframework.core.env.Environment; import org.springframework.core.env.Profiles; @Bean public Docket createDocket(Environment environment) { // 设置要显示swagger的环境 Profiles of = Profiles.of(\"dev\", \"test\"); // 通过 enable() 接收此参数判断是否要显示 boolean flag = environment.acceptsProfiles(of); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(flag) //是否启用 Swagger ，false 为浏览器无法访问 .select() .apis(RequestHandlerSelectors.basePackage(\"com.wukongnotnull.controller\")) // 通过请求路径再过滤 .paths(PathSelectors.ant(\"/wukong/**\")) .build(); } 文档分组展示 接口文档根据不同开发者进行分组展示，开发者分别是 wukong , zhubajie , shaseng 默认组名为 default ,通过 groupName() 可配置分组 @Bean public Docket createDocket() { return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()) .groupName(\"wukong\") // 配置分组 // 省略配置.... } 配置多个分组 @Bean public Docket createDocket1(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"zhubajie\"); } @Bean public Docket createDocket2(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"shaseng\"); } UI 界面拓展 默认的UI 访问 http://localhost:8080/swagger-ui.html io.springfox springfox-swagger-ui 2.9.2 bootstrap-ui 访问 http://localhost:8080/doc.html com.github.xiaoymin swagger-bootstrap-ui 1.9.1 Layui-ui 访问 http://localhost:8080/docs.html com.github.caspar-chen swagger-ui-layer 1.1.3 mg-ui 访问 http://localhost:8080/document.html com.zyplayer swagger-mg-ui 1.0.6 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/Integrated-swagger/integrated-swagger.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-03 15:48:45 "},"fore-end-separation/cors.html":{"url":"fore-end-separation/cors.html","title":"CORS 跨域处理","keywords":"","body":" CORS 跨域处理 跨域 浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 CORS 解决跨域 CORS是一个W3C标准，全称是”跨域资源共享” Cross-origin resource sharing ，允许浏览器向跨源服务器，发出 XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 它通过服务器增加一个特殊的 Header[Access-Control-Allow-Origin] 来告诉客户端跨域的限制，如果浏览器支持 CORS ,并且判断Origin通过的话，就会允许XMLHttpRequest发起跨域请求。 SpringBoot 使用 CORS 解决跨域 方法一 @CrossOrigin 后端项目中源码： 方法或者类上添加 @CrossOrigin 注解 Controller package com.wukongnotnull.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; //author: 悟空非空也（B站/知乎/公众号） @Controller @RequestMapping(\"/api/v1\") @CrossOrigin public class UserController { @ResponseBody @GetMapping(value = \"/users\") public String getUserList(){ return \"获得用户列表成功\"; } } html 前端项目中的源码： 首页 $(function () { $(\"#btn\").click(function () { console.log(\"test....\"); $.ajax({ url:'http://localhost:8080/api/v1/users', methods:'get', success:function (res) { console.log(res); }, error:function (err) { console.log(err); } }); }) }); 方法一：查询所有用户信息 方法二： 点击查询所有用户信息 方法二 重写 addCorsMappings 方法 后端项目中源码： 创建处理跨域的配置类 配置类 @Configuration public class MyWebMvcConfigurer implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { // 设置允许跨域的路径 registry.addMapping(\"/**\") // 设置允许跨域请求的域名 .allowedOriginPatterns(\"*\") // 是否允许 cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\") // 设置允许的 header 属性 .allowedHeaders(\"*\") // 允许跨域最大时长 .maxAge(3600); } } html 前端项目中的源码： 首页 $(function () { $(\"#btn\").click(function () { console.log(\"test....\"); $.ajax({ url:'http://localhost:8080/api/v1/users', methods:'get', success:function (res) { console.log(res); }, error:function (err) { console.log(err); } }); }) }); 方法一：查询所有用户信息 方法二： 点击查询所有用户信息 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/fore-end-separation/cors.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-01 22:42:45 "},"fore-end-separation/token-login.html":{"url":"fore-end-separation/token-login.html","title":"Token 登录","keywords":"","body":" Token 在前后端分离的场景中，采用 Token 方案进行登录验证。登录成功时，后端根据用户信息生成一个 Token 字符串返回给前端（客户端）存储。 前端再次发送请求时，若存在 token ，会放入请求头中发送给后端。后端进行解析比对，如果解析比对不成功（比如，token 超时或者token信息错误），表示为未登录。 原理类似 Session 。 Token 生成方案-JWT 目前企业中运用比较多的，是使用 JWT 技术来生成 token 。 引入依赖 io.jsonwebtoken jjwt 0.9.0 设计工具类来生成和解析token import io.jsonwebtoken.Claims; import io.jsonwebtoken.JwtBuilder; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; import java.util.Date; import java.util.UUID; /** * JWT工具类 */ public class JwtUtil { //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = \"wukongnotnull\"; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) { SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null){ ttlMillis=JwtUtil.JWT_TTL; } long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); SecretKey secretKey = generalKey(); JwtBuilder builder = Jwts.builder() .setId(id) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(\"sg\") // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate);// 设置过期时间 return builder.compact(); } /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() { byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \"AES\"); return key; } /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception { SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); } } 登录接口实现 数据准备 DROP TABLE IF EXISTS `sys_user`; CREATE TABLE `sys_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `password` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; /*Data for the table `sys_user` */ insert into `sys_user`(`id`,`username`,`password`) values (1,'root','root'),(2,'sangeng','caotang'); 实体类 @Data @NoArgsConstructor @AllArgsConstructor public class SystemUser { private Integer id; private String username; private String password; } SystemUserController import com.wukongnotnull.domain.ResponseResult; import com.wukongnotnull.domain.SystemUser; import com.wukongnotnull.service.SystemUserService; import com.wukongnotnull.utils.JwtUtil; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.HashMap; import java.util.Map; import java.util.UUID; @RestController @RequestMapping(\"/sys_user\") public class SystemUserController { @Autowired private SystemUserService userService; @PostMapping(\"/login\") public ResponseResult login(@RequestBody SystemUser user) { //校验用户名密码是否正确 SystemUser loginUser = userService.login(user); Map map; if (loginUser != null) { //如果正确 生成token返回 map = new HashMap<>(); String token = JwtUtil.createJWT(UUID.randomUUID().toString(), String.valueOf(loginUser.getId()), null); map.put(\"token\", token); } else { //如果不正确 给出相应的提示 return new ResponseResult(300, \"用户名或密码错误，请重新登录\"); } return new ResponseResult(200, \"登录成功\", map); } } Service public interface SystemUserService { public SystemUser login(SystemUser user); } @Service public class SystemUserServcieImpl implements SystemUserService { public login(User user){ if() } @Override public SystemUser login(SystemUser user) { SystemUser loginUser = this.login(user); return loginUser; } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/fore-end-separation/token-login.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-01 22:44:47 "},"fore-end-separation/token-authorization.html":{"url":"fore-end-separation/token-authorization.html","title":"Token  授权","keywords":"","body":" Token 登录 拦截器 ​ 如果我们想在多个Handler方法执行之前或者之后都进行一些处理，甚至某些情况下需要拦截掉，不让Handler方法执行。那么可以使用SpringMVC为我们提供的拦截器。 使用步骤 创建类实现HandlerInterceptor接口 public class LoginInterceptor implements HandlerInterceptor { } 实现方法 @Component public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //获取请求头中的token String token = request.getHeader(\"token\"); //判断token是否为空，如果为空也代表未登录 提醒重新登录（401） if(!StringUtils.hasText(token)){ response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return false; } //解析token看看是否成功 try { Claims claims = JwtUtil.parseJWT(token); String subject = claims.getSubject(); System.out.println(subject); } catch (Exception e) { e.printStackTrace(); //如果解析过程中没有出现异常说明是登录状态 //如果出现了异常，说明未登录，提醒重新登录（401） response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return false; } return true; } } 配置拦截器 @Configuration public class LoginConfig implements WebMvcConfigurer { @Autowired private LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(loginInterceptor)//添加拦截器 .addPathPatterns(\"/**\") //配置拦截路径 .excludePathPatterns(\"/sys_user/login\");//配置排除路径 } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/fore-end-separation/token-authorization.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-01 00:09:39 "},"fore-end-separation/argument-resolve.html":{"url":"fore-end-separation/argument-resolve.html","title":"自定义参数解析","keywords":"","body":" 自定义参数解析 如果我们想实现像获取请求体中的数据那样，在Handler方法的参数上增加一个@RepuestBody注解就可以获取到对应的数据的话。 可以使用HandlerMethodArgumentResolver来实现自定义的参数解析。 案例 实现当前用户token 值和形参的绑定 定义用来标识的注解 @Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) public @interface CurrentUserId { } 创建类实现HandlerMethodArgumentResolver接口并重写其中的方法 注意加上@Component注解注入Spring容器 public class UserIdArgumentResolver implements HandlerMethodArgumentResolver { //判断方法参数使用能使用当前的参数解析器进行解析 @Override public boolean supportsParameter(MethodParameter parameter) { //如果方法参数有加上CurrentUserId注解，就能把被我们的解析器解析 return parameter.hasParameterAnnotation(CurrentUserId.class); } //进行参数解析的方法，可以在方法中获取对应的数据，然后把数据作为返回值返回。方法的返回值就会赋值给对应的方法参数 @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { //获取请求头中的token String token = webRequest.getHeader(\"token\"); if(StringUtils.hasText(token)){ //解析token，获取userId Claims claims = JwtUtil.parseJWT(token); String userId = claims.getSubject(); //返回结果 return userId; } return null; } } 配置参数解析器 @Configuration public class ArgumentResolverConfig implements WebMvcConfigurer { @Autowired private UserIdArgumentResolver userIdArgumentResolver; @Override public void addArgumentResolvers(List resolvers) { resolvers.add(userIdArgumentResolver); } } 测试 在需要获取UserId的方法中增加对应的方法参数然后使用@CurrentUserId进行标识即可获取到数据 @RestController @RequestMapping(\"/user\") //@CrossOrigin public class UserController { @Autowired private UserServcie userServcie; @RequestMapping(\"/findAll\") public ResponseResult findAll(@CurrentUserId String userId) throws Exception { System.out.println(userId); //调用service查询数据 ，进行返回s List users = userServcie.findAll(); return new ResponseResult(200,users); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/fore-end-separation/argument-resolve.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-01 00:09:39 "},"cache-management/cache-management.html":{"url":"cache-management/cache-management.html","title":"缓存管理","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/cache-management/cache-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"cache-management/env-setup.html":{"url":"cache-management/env-setup.html","title":"基础环境搭建","keywords":"","body":" 基础环境搭建 创建项目 pom.xml org.springframework.boot spring-boot-starter-data-jpa org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-devtools runtime true mysql mysql-connector-java runtime org.projectlombok lombok true 配置文件配置 #mysql数据库连接配置 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/wukong_blog?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&autoReconnect=true username: root password: rootroot # 显示 sql 语句 jpa: show-sql: true 实体类 import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; @Data @NoArgsConstructor @AllArgsConstructor @Entity(name = \"b_comment\") public class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = \"content\") private String content; @Column(name = \"author\") private String author; @Column(name = \"article_id\") private Integer articleId; } 编写自定义仓库类，继承JpaRepository package com.wukongnotnull.repository; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Comment; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import javax.transaction.Transactional; import java.util.List; import java.util.Optional; public interface CommentRepository extends JpaRepository { @Override List findAll(); @Override Optional findById(Integer id); // 查询条件：作者不为空 List findByAuthorNotNull(); @Override long count(); @Override S saveAndFlush(S s); @Query(\"select c from b_comment c where c.articleId=?1\") List getCommentList(Integer articleId); @Query(value = \"select * from b_comment c where c.article_id=?1\",nativeQuery = true) List getCommentList2(Integer articleId); @Transactional @Modifying @Query(value = \"update b_comment set author =?1 where id =?2 \",nativeQuery = true) int updateComment(String author,Integer id); @Transactional @Modifying @Query(value = \"delete from b_comment where id = ?1\",nativeQuery = true) int deleteComment(Integer id); @Override S save(S entity); } service层 package com.wukongnotnull.service; import com.wukongnotnull.domain.Comment; import java.util.Optional; public interface CommentService { //add public Comment addComment(Comment comment); //delete public void deleteComment(Integer id); //modify public int modifyComment(Integer id,String author); //query public Comment findById(Integer id); } package com.wukongnotnull.service; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.Optional; @Service public class CommentServiceImpl implements CommentService { @Autowired public CommentRepository commentRepository; //add public Comment addComment(Comment comment){ return this.commentRepository.save(comment); } //delete public void deleteComment(Integer id){ this.commentRepository.deleteById(id); } //modify public int modifyComment(Integer id,String author){ return this.commentRepository.updateComment(author,id); } //query public Comment findById(Integer id){ Optional optional = this.commentRepository.findById(id); if(optional.isPresent()){ return optional.get(); } return null; }; } controller层 package com.wukongnotnull.controller; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.service.CommentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class CommentController { @Autowired private CommentService commentService; //query @GetMapping(\"/query/{id}\") public Comment findById(@PathVariable(\"id\") Integer id){ return this.commentService.findById(id); } //modify @GetMapping(\"/modify/{id}/{author}\") public int modifyBy(@PathVariable(\"id\") Integer id,@PathVariable(\"author\") String author){ int i = this.commentService.modifyComment(id, author); return i; } //delete @GetMapping(\"/delete/{id}\") public void deleteById(@PathVariable(\"id\") Integer id){ this.commentService.deleteComment(id); } //add } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/cache-management/env-setup.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-01 00:09:40 "},"cache-management/default-cache.html":{"url":"cache-management/default-cache.html","title":"默认缓存","keywords":"","body":" Spring Boot默认缓存体验 spring boot 自带缓存机制，可以使用默认缓存，避免每次查询都去数据库访问一边，避免资源消耗 在启动类上添加注解 @EnableCaching package com.wukongnotnull; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cache.annotation.EnableCaching; @SpringBootApplication @EnableCaching //开启springboot默认缓存 public class RedisSpringbootApplication { public static void main(String[] args) { SpringApplication.run(RedisSpringbootApplication.class, args); } } 在service层的实现类的方法上添加注解 @Cacheable，开启缓存空间 package com.wukongnotnull.service; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; import java.util.Optional; @Service public class CommentServiceImpl implements CommentService { @Autowired public CommentRepository commentRepository; //add public Comment addComment(Comment comment){ return this.commentRepository.save(comment); } //delete public void deleteComment(Integer id){ this.commentRepository.deleteById(id); } //modify public int modifyComment(Integer id,String author){ return this.commentRepository.updateComment(author,id); } //query @Cacheable(cacheNames = \"comment\")//创建缓存空间，并命名为comment public Comment findById(Integer id){ Optional optional = this.commentRepository.findById(id); if(optional.isPresent()){ return optional.get(); } return null; }; } 测试，多次查询，在控制台只打印第一次查询日志 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/cache-management/default-cache.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-01 00:09:39 "},"cache-management/integrate-redis.html":{"url":"cache-management/integrate-redis.html","title":"redis 缓存","keywords":"","body":" Redis 缓存介绍 基于注解的 Redis 缓存实现 pom中添加redis的依赖启动器 org.springframework.boot spring-boot-starter-data-redis 配置redis的连接配置 #redis数据库的连接配置 spring: redis: host: 127.0.0.1 port: 6379 password: 启动类上添加注解@EnableCaching @SpringBootApplication @EnableCaching//开启springboot默认缓存 public class RedisSprongbootApplication { public static void main(String[] args) { SpringApplication.run(RedisSprongbootApplication.class, args); } } service层上对删改查操作添加redis缓存注解 增加功能直接插入mysql数据库 package com.wukongnotnull.repository; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cache.annotation.CacheEvict; import org.springframework.cache.annotation.CachePut; import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; import java.util.Optional; @Service public class CommentServiceImpl implements CommentService { @Autowired public CommentRepository commentRepository; //add public Comment addComment(Comment comment){ return this.commentRepository.save(comment); } //delete @CacheEvict(cacheNames = \"comment\")//删除使用@CacheEvict public void deleteComment(Integer id){ this.commentRepository.deleteById(id); } //modify @CachePut(cacheNames = \"comment\",key =\"#result.id\")//更新使用，@CachePut,此处返回类型不能为int，因为缓存数据库中为int，再次查询需要的是Comment /* public int modifyComment(Integer id,String author){ return this.commentRepository.updateComment(author,id); }*/ public Comment modifyComment(Integer id,String author){//注意：key =\"#result.id\" 不是key =\"#result\" int i = this.commentRepository.updateComment(author, id); //再次查询操作,查询结果存入redis缓存中 return this.findById(id); } //query @Cacheable(cacheNames = \"comment\",unless = \"#result==null\")//创建缓存空间，并命名为comment,如果查询结果为null，不存入该空间 public Comment findById(Integer id){ Optional optional = this.commentRepository.findById(id); if(optional.isPresent()){ return optional.get(); } return null; }; } 实体类序列化 package com.wukongnotnull.domain; //author: 悟空非空也（B站/知乎/公众号） import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; import java.io.Serializable; @Data @NoArgsConstructor @AllArgsConstructor @Entity(name = \"b_comment\") public class Comment implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = \"content\") private String content; @Column(name = \"author\") private String author; @Column(name = \"article_id\") private Integer articleId; } 自定义RedisCacheManager（基于注解的缓存数据的json格式化） 基于注解的，基于api的无效，实体类可以删除ImplementSeriable 序列化 测试之前，先清空 Redis 数据库中的数据，不然会因数据库中的乱码产生报错 package com.wukongnotnull.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.cache.RedisCacheConfiguration; import org.springframework.data.redis.cache.RedisCacheManager; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.RedisSerializationContext; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import java.time.Duration; @Configuration//定义为配置类 public class RedisConfig { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { // 分别创建String和JSON格式序列化对象，对缓存数据key和value进行转换 RedisSerializer strSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer<>(Object.class); // 解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jacksonSeial.setObjectMapper(om); // 定制缓存数据序列化方式及时效 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofDays(1)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(strSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jacksonSeial)) .disableCachingNullValues(); return RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(config).build(); } } 使用 Redis Desktop Manager 客户端查看数据库情况 基于 API 的 Redis 缓存实现 @SpringBootApplication public class RedisSprongbootApplication { public static void main(String[] args) { SpringApplication.run(RedisSprongbootApplication.class, args); } } 实体类Comment package com.wukongnotnull.domain; //author: 悟空非空也（B站/知乎/公众号） import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; import java.io.Serializable; @Data @NoArgsConstructor @AllArgsConstructor @Entity(name = \"b_comment\") public class Comment implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = \"content\") private String content; @Column(name = \"author\") private String author; @Column(name = \"article_id\") private Integer articleId; } repository:CommentRepository package com.wukongnotnull.repository; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Comment; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import javax.transaction.Transactional; import java.util.List; import java.util.Optional; public interface CommentRepository extends JpaRepository { @Override List findAll(); @Override Optional findById(Integer id); // 查询条件：作者不为空 List findByAuthorNotNull(); @Override long count(); @Override S saveAndFlush(S s); @Query(\"select c from b_comment c where c.articleId=?1\") List getCommentList(Integer articleId); @Query(value = \"select * from b_comment c where c.article_id=?1\",nativeQuery = true) List getCommentList2(Integer articleId); @Transactional @Modifying @Query(value = \"update b_comment set author =?1 where id =?2 \",nativeQuery = true) int updateComment(String author,Integer id); @Transactional @Modifying @Query(value = \"delete from b_comment where id = ?1\",nativeQuery = true) int deleteComment(Integer id); @Override S save(S entity); } service: ApiCommentService package com.wukongnotnull.service; import ch.qos.logback.core.util.TimeUtil; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.Optional; import java.util.concurrent.TimeUnit; @Service @Transactional public class ApiCommentService { @Autowired private CommentRepository commentRepository; @Autowired // 引入 RedisTemplate private RedisTemplate redisTemplate; /** * 查询方法 */ public Comment findById(Integer id){ //先到缓存中查询 Comment comment = (Comment) redisTemplate.opsForValue().get(\"comment_\" + id); if(comment!=null){ //缓存中有数据 return comment; }else{//缓存中没有数据 //到数据库中进行查询 Optional byId = commentRepository.findById(id); if(byId.isPresent()){ //若是数据库中存在，将数据先存入redis Comment comment1 = byId.get(); redisTemplate.opsForValue().set(\"comment_\"+id,comment1,1, TimeUnit.DAYS); return comment1; } System.out.println(\"缓存中没有数据的情况下，数据库中也没有\"); return null; } } /** * 更新方法 */ public Comment updateComment(Comment comment){ //更新mysql数据库 int i = commentRepository.updateComment(comment.getAuthor(), comment.getId()); //更新redis缓存 redisTemplate.opsForValue().set(\"comment_\"+comment.getId(),comment); //更新后进行查询 return this.findById(comment.getId()); } /** * 删除方法 */ public void deleteComment(Integer id){ //删除 mysql 数据库中的数据 commentRepository.deleteById(id); //删除redis缓存中的数据 redisTemplate.delete(\"comment_\" + id); } } controller:ApiCommentController package com.wukongnotnull.controller; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.service.ApiCommentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/api\") public class ApiCommentController { @Autowired private ApiCommentService apiCommentService; //query @GetMapping(\"/query/{id}\") public Comment findById(@PathVariable(\"id\") Integer id){ return this.apiCommentService.findById(id); } //modify @GetMapping(\"/modify/{id}/{author}\") public Comment modifyBy(@PathVariable(\"id\") Integer id,@PathVariable(\"author\") String author){ Comment comment = new Comment(); comment.setId(id); comment.setAuthor(author); return this.apiCommentService.updateComment(comment); } //delete @GetMapping(\"/delete/{id}\") public void deleteById(@PathVariable(\"id\") Integer id){ this.apiCommentService.deleteComment(id); } //add } 自定义RedisTemplate(基于api的缓存数据json格式化) 痛点 缓存管理的实体类使用的jdk序列化机制，缺点：不便于可视化 缓存中的数据进行json序列化 对基于api的redis缓存有效，注解无效 package com.wukongnotnull.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.cache.RedisCacheConfiguration; import org.springframework.data.redis.cache.RedisCacheManager; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.RedisSerializationContext; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import java.time.Duration; @Configuration // 定义一个配置类 public class RedisConfig { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); // 使用JSON格式序列化对象，对缓存数据key和value进行转换 Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class); // 解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jacksonSeial.setObjectMapper(om); // 设置RedisTemplate模板API的序列化方式为JSON template.setDefaultSerializer(jacksonSeial); return template; } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/cache-management/integrate-redis.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-01 00:09:39 "},"cache-management/integrate-ehcache.html":{"url":"cache-management/integrate-ehcache.html","title":"整合 ehcache","keywords":"","body":" 集成 ehcache缓存框架 EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 Spring 提供了对缓存功能的抽象：即允许绑定不同的缓存解决方案（如Ehcache），但本身不直接提供缓存功能的实现。它支持注解方式使用缓存，非常方便。 ehcache 和 redis 比较 　　ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。 　　redis是通过socket访问到缓存服务，效率比Ehcache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。 　　ehcache也有缓存共享方案，不过是通过RMI或者Jgroup多播方式进行广播缓存通知更新，缓存共享复杂，维护不方便；简单的共享可以，但是涉及到缓存恢复，大数据缓存，则不合适。 实操 pom org.springframework.boot spring-boot-starter-cache net.sf.ehcache ehcache src/main/resources/ehcache.xml application.xml # 缓存的配置 spring: cache: ehcache: config: classpath:ehcache.xml # 开启dao层的dubug日志，打印出sql语句，便于缓存测试分析 logging: level: com.wukong.dao: debug 实体类序列化 public class User implements Serializable { } 启动类 @SpringBootApplication @EnableCaching public class App { public static void main( String[] args ) { SpringApplication.run(App.class); System.out.println( \"Hello World!\" ); } } service层设置缓存 @Service public class UserServiceImpl implements UserService { @Cacheable(value = \"users\", key = \"#username\") public User getUserByUsername(String username) { } @Cacheable(value = \"users\",key = \"#id\") public User getUserById(Integer id) { } // 添加用户，不需要添加到缓存容器中 public void addUser(User user) { } // 修改用户，返回类型不能是void， // 参数是对象是，使用 #user.id 作为关键词 // @CachePut 作用：修改数据库的同时，同步修改缓存容器 // 当然也可以直接使用@CacheEvict ,修改数据库同时删除缓存容器中该数据 @CachePut(value = \"users\", key = \"#user.id\") public User modifyUser(User user) { return user; } // @CacheEvict 作用： 删除数据库的同时，删除缓存容器 @CacheEvict(value = \"users\", allEntries = true) public void deleteUser(Integer id) { } //参数是封装对象时，可以使用多个key ，写法如下 @Cacheable(value = \"users\" ,key = \"#userParams.pageNum+'-'+#userParams.pageSize+'-'+#userParams.username\") public PageInfo getUserPageList(UserParams userParams) { } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/cache-management/integrate-ehcache.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-09-01 00:09:40 "},"security-management/security-management.html":{"url":"security-management/security-management.html","title":"安全管理","keywords":"","body":"SpringSecurity介绍 Spring Security 快速入门 pom.xml org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web 直接url访问 默认显示 登录界面，该界面是由spring security提供的 用户名 user 密码 启动项目时候，在控制台随机生成 Mvc Security 安全配置介绍 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/security-management/security-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"security-management/authentication.html":{"url":"security-management/authentication.html","title":"Security 身份认证","keywords":"","body":"内存身份认证 自定义用户名和密码，该方法适用于测试环境，临时使用 package com.wukongnotnull.config; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; //author: 悟空非空也（B站/知乎/公众号） @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //设置密码编码器 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); // 内存身份认证，模拟测试用户 InMemoryUserDetailsManagerConfigurer builder = auth.inMemoryAuthentication().passwordEncoder(bCryptPasswordEncoder); builder.withUser(\"wukong\").password(bCryptPasswordEncoder.encode(\"wukong\")).roles(\"common\"); builder.withUser(\"admin\").password(bCryptPasswordEncoder.encode(\"admin\")).roles(\"vip\"); } } JDBC 身份认证 sql 脚本 #use database USE springbootdata; #create t_customer 并插入相关数据 DROP TABLE IF EXISTS `t_customer`; CREATE TABLE t_customer ( `id` INT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY, username VARCHAR(200), `password` VARCHAR(200), `valid` TINYINT(1) NOT NULL DEFAULT '1' ); INSERT INTO t_customer VALUES( '1','wukong','wukong','1' ),( '2','admin','admin','1' ); #创建表 t_authority 并插入数据 DROP TABLE IF EXISTS `t_authority`; CREATE TABLE `t_authority`( id INT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY, authority VARCHAR(20) ); INSERT INTO `t_authority` VALUES( 1,'ROLE_common' ),(2,'ROLE_vip'); #创建中间表 t_customer_authority，并插入数据 DROP TABLE IF EXISTS `t_customer_authority`; CREATE TABLE `t_customer_authority`( id INT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY, customer_id INT(20), authority_id INT(20) ); INSERT INTO `t_customer_authority` VALUES( '1','1','1' ),( '2','2','2' ); 配置mysql连接和redis连接 # MySQL spring.datasource.url=jdbc:mysql://localhost:3306/springbootdata?serverTimezone=UTC spring.datasource.username=root spring.datasource.password=root spring.thymeleaf.cache=false 添加依赖 org.springframework.boot spring-boot-starter-jdbc mysql mysql-connector-java 编写安全配置类 package com.wukong.config; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import javax.sql.DataSource; @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private DataSource dataSource; //重写 configure方法 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //设置密码编码器 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); //使用jdbc进行身份认证 String userSQL =\"select username,password,valid from t_customer \" + \"where username = ?\"; String authoritySQL=\"select c.username,a.authority from t_customer c,t_authority a,\"+ \"t_customer_authority ca where ca.customer_id=c.id \" + \"and ca.authority_id=a.id and c.username =?\"; auth.jdbcAuthentication().passwordEncoder(bCryptPasswordEncoder) .dataSource(dataSource) .usersByUsernameQuery(userSQL) .authoritiesByUsernameQuery(authoritySQL); } } 登录测试 1 对密码进行编码加密 @Test void contextLoads() { //设置密码编码器 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); String wukong = bCryptPasswordEncoder.encode(\"wukong\"); String admin = bCryptPasswordEncoder.encode(\"admin\"); System.out.println(\"wukong = \" + wukong); System.out.println(\"admin = \" + admin); System.out.println(\"是否编码成功？---> \" + bCryptPasswordEncoder.matches(\"wukong\", wukong)); } 2 生成的密码保存到数据库中 UserDetailService 身份认证 pom.xml org.springframework.boot spring-boot-starter-data-redis org.springframework.boot spring-boot-starter-data-jpa mysql mysql-connector-java runtime org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-web domain: Authority package com.wukongnotnull.domain; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import java.io.Serializable; @Entity(name = \"t_authority\") public class Authority implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String authority; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getAuthority() { return authority; } public void setAuthority(String authority) { this.authority = authority; } @Override public String toString() { return \"Authority{\" + \"id=\" + id + \", authority='\" + authority + '\\'' + '}'; } } Customer package com.wukongnotnull.domain; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import java.io.Serializable; @Entity(name = \"t_customer\") public class Customer implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String username; private String password; private Integer valid; public Integer getValid() { return valid; } public void setValid(Integer valid) { this.valid = valid; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } repository: AuthorityRepository package com.wukongnotnull.repository; import com.wukong.domain.Authority; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Query; import java.util.List; public interface AuthorityRepository extends JpaRepository { @Query(value = \"select a.* from t_customer c,t_authority a,t_customer_authority ca where ca.customer_id=c.id and ca.authority_id=a.id and c.username =?1\",nativeQuery = true) public List findAuthoritiesByUsername(String username); } CustomerRepository package com.wukong.repository; import com.wukong.domain.Customer; import org.springframework.data.jpa.repository.JpaRepository; public interface CustomerRepository extends JpaRepository { Customer findByUsername(String username); } service: CustomerService package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.domain.Customer; public interface CustomerService { // 根据用户名查询用户信息 Customer findByUsername(String username); } AuthorityService package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.domain.Authority; import java.util.List; public interface AuthorityService { public List findAuthoritiesByUsername(String username); } CustomerServiceImpl package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.dao.CustomerRepository; import com.wukongnotnull.domain.Customer; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; @Service public class CustomerServiceImpl implements CustomerService{ @Autowired private CustomerRepository customerRepository; @Autowired private RedisTemplate redisTemplate; // 整合redis缓存,根据用户名查询用户信息 public Customer findByUsername(String username){ Customer customer=null; Object o = redisTemplate.opsForValue().get(\"customer_\"+username); if(o!=null){ customer=(Customer)o; }else { customer = customerRepository.findByUsername(username); if(customer!=null){ redisTemplate.opsForValue().set(\"customer_\"+username,customer); } } return customer; } } AuthorityServiceImpl package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.dao.AuthorityRepository; import com.wukongnotnull.domain.Authority; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; import java.util.List; @Service public class AuthorityServiceImpl implements AuthorityService{ @Autowired private AuthorityRepository authorityRepository; @Autowired private RedisTemplate redisTemplate; // 整合 redis 缓存，根据唯一用户名查询权限列表 public List findAuthoritiesByUsername(String username){ List authorities=null; Object o = redisTemplate.opsForValue().get(\"authorities_\" + username); if(o!=null){ authorities=(List) o; }else { authorities=authorityRepository.findAuthoritiesByUsername(username); if(authorities.size()>0){ redisTemplate.opsForValue().set(\"authorities_\"+username,authorities); } } return authorities; } } UserDetailsServiceImpl package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.domain.Authority; import com.wukongnotnull.domain.Customer; import lombok.Data; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Service; import java.util.List; import java.util.stream.Collectors; @Service public class UserDetailsServiceImpl implements UserDetailsService { @Autowired private CustomerService customerService; @Autowired private AuthorityService authorityService; /** * Locates the user based on the username. In the actual implementation, the search * may possibly be case sensitive, or case insensitive depending on how the * implementation instance is configured. In this case, the UserDetails * object that comes back may have a username that is of a different case than what * was actually requested.. * * @param username the username identifying the user whose data is required. * @return a fully populated user record (never null) * @throws UsernameNotFoundException if the user could not be found or the user has no * GrantedAuthority */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { //通过业务方法获取用户及权限信息 Customer customer = customerService.findByUsername(username); List authorities = authorityService.findAuthoritiesByUsername(username); // 对用户权限进行封装 List authorityList = authorities.stream(). map(authority -> new SimpleGrantedAuthority(authority.getAuthority())) .collect(Collectors.toList()); // 返回封装的UserDetails用户详情类 if(customer!=null){ // 同名用户存在，那么密码是否一致呢？ UserDetails userDetails= new User(customer.getUsername(),customer.getPassword(),authorityList); return userDetails; } else { // 如果查询的用户不存在（用户名不存在），必须抛出此异常 throw new UsernameNotFoundException(\"当前用户不存在！\"); } } } SecurityConfig 使用Springboot集合Springsecurity的时候，报了一个java.lang.IllegalArgumentException: There is no PasswordEncoder 原因 security 1.5.0以上的版本，增加多种的加密方式，为了增加安全，要求将密码通过加密算法处理过后才存入数据库。 客户端传递过来的明文密码需要加密后，和数据库中的暗文进行对比，实现身份验证。 package com.wukongnotnull.config; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; //author: 悟空非空也（B站/知乎/公众号） @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserDetailsService userDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //设置密码编码器 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); //使用 UserDetailsService 进行身份认证时，对明文密码进行加密 auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder); } } 登录测试 用户名 密码 wukong wukong admin admin 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/security-management/authentication.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"security-management/authorization.html":{"url":"security-management/authorization.html","title":"Security 权限认证","keywords":"","body":"悟空编号 学前素材准备 前端资源（html css js image 等等） 链接：https://share.weiyun.com/QD9u6jjX 密码：wukong 自定义用户访问控制 访问首页授权 index.html 访问静态资源（图片和样式）授权 @Override protected void configure(HttpSecurity http) throws Exception { // 自定义用户授权管理 http.authorizeRequests() // 所有人都可以访问 .antMatchers(\"/\").permitAll() // 需要对static文件夹下静态资源（图片和样式）进行统一放行 .antMatchers(\"/login/**\").permitAll() // 访问如下请求需要 角色（权限）是 common 或者 vip .antMatchers(\"/detail/common/**\").hasAnyRole(\"common\",\"vip\") .antMatchers(\"/detail/vip/**\").hasRole(\"vip\") // 任何请求访问都需要先进行身份认证 .anyRequest().authenticated(); } Spring Security 中的 hasRole 和 hasAuthority 有区别吗？ https://cloud.tencent.com/developer/article/1703187 hasRole() public ExpressionInterceptUrlRegistry hasRole(String role) { return access(ExpressionUrlAuthorizationConfigurer.hasRole(role)); } private static String hasRole(String role) { Assert.notNull(role, \"role cannot be null\"); if (role.startsWith(\"ROLE_\")) { throw new IllegalArgumentException( \"role should not start with 'ROLE_' since it is automatically inserted. Got '\" + role + \"'\"); } return \"hasRole('ROLE_\" + role + \"')\"; } 自定义用户登录页面 用户登录界面 请登录 用户名或密码错误，请重新登录！ 记住我 登录 Copyright© 2050-3030 package com.wukongnotnull.controller; import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContext; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.ResponseBody; //author: 悟空非空也（B站/知乎/公众号） @Controller public class LoginController { @GetMapping(\"/userLogin\") //路径要和 提交登录表单的url 一致 public String index(){ return \"login/login\"; } } package com.wukongnotnull.config; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import javax.sql.DataSource; //author: 悟空非空也（B站/知乎/公众号） @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { // 自定义用户登录控制 // 技巧： 获得登录页和处理登录信息的 url 都是 /userLogin , post 请求进入如下方法 http.authorizeRequests().and() // 开启登录功能 .formLogin() // 访问登录页面（自定义登录路径） .loginPage(\"/userLogin\").permitAll() // 指定登录处理的 url ，对应action的值 .loginProcessingUrl(\"/userLogin\") .usernameParameter(\"name\") .passwordParameter(\"pwd\") // 登录成功后，访问首页 / .defaultSuccessUrl(\"/\") // 登录失败后，访问 /userLogin?error .failureUrl(\"/userLogin?error\"); } } 自定义用户退出 @Override protected void configure(HttpSecurity http) throws Exception { // 退出 http // 开启退出功能 .logout() // 访问 /logout 执行退出功能 .logoutUrl(\"/logout\") // 退出成功，访问首页 / .logoutSuccessUrl(\"/\"); } 登录用户信息获取 /** * 通过 Security 提供的 SecurityContextHolder 获取登录用户信息 * @return String */ @GetMapping(\"/userInfo\") @ResponseBody public String getUser(){ // 获取应用上下文 SecurityContext context = SecurityContextHolder.getContext(); // 获取用户相关信息 Authentication authentication = context.getAuthentication(); UserDetails userDetails = (UserDetails)authentication.getPrincipal(); System.out.println(\"username: \"+userDetails.getUsername()); return \"登录的用户名为： \" + userDetails.getUsername(); } 记得我功能 记住我 USE springbootdata; # 来源于 JdbcTokenRepositoryImpl create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null); org.springframework.boot spring-boot-starter-jdbc // 使用jdbc 技术访问数据库 @Autowired private DataSource dataSource; /** * 持久化Token存储 * @return */ @Bean public JdbcTokenRepositoryImpl tokenRepository(){ JdbcTokenRepositoryImpl jr=new JdbcTokenRepositoryImpl(); jr.setDataSource(dataSource); return jr; } @Override protected void configure(HttpSecurity http) throws Exception { // 记住我 http.rememberMe() .rememberMeParameter(\"rememberMe\") .tokenValiditySeconds(60*60*24*7) .tokenRepository(this.tokenRepository()); } CSRF防护功能 跨站伪造用户，获得真实用户的 session 信息，伪造成真实用户，进行非法操作。 form 表单使用 csrf 防护 修改用户 用户名: 修改用户名 package com.wukongnotnull.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import javax.servlet.http.HttpServletRequest; //author: 悟空非空也（B站/知乎/公众号） @Controller public class CSRFController { @GetMapping(\"/updateUser\") public String updateUser(){ return \"csrf/csrfTest\"; } @ResponseBody @PostMapping(\"/updateUser\") public String updateUser(@RequestParam(\"username\") String username, HttpServletRequest request ){ System.out.println(\"request = \" + request); String csrf_token=request.getParameter(\"_csrf\"); System.out.println(\"csrf_token = \" + csrf_token); System.out.println(\"username = \" + username); return \"success\"; } } ajax 使用 csrf 防护 //针对ajax数据修改的CSRF Token配置 $(function () { var token = $(\"meta[name='_csrf']\").attr(\"content\"); var headerName = $(\"meta[name='_csrf_header']\").attr(\"content\"); $(document).ajaxSend(function(e, xhr, options) { xhr.setRequestHeader(headerName, token); }); }); Security 管理前端页面内容呈现 不同权限，页面内容针对性呈现不同的内容 应用场景： 动态菜单的实现 org.thymeleaf.extras thymeleaf-extras-springsecurity5 (1)sec:authorize=\"isAuthenticated()\" 判断用户是否已经登陆认证，引号内的参数必须是isAuthenticated()。 (2)sec:authentication=“name” 获得当前用户的用户名，引号内的参数必须是name。 (3)sec:authorize=“hasRole(‘role’)” 判断当前用户是否拥有指定的权限。引号内的参数为权限的名称。 (4)sec:authentication=\"principal.authorities\" 获得当前用户的全部角色，引号内的参数必须是principal.authorities。 index.html 新浪新闻平台 欢迎新浪新闻首页 游客您好，如果想查看会员新闻请登录 用户: 您的权限：，您有权观看以下内容 游客 - 新闻专栏 新闻1：悟空非空也带你学习 Java 新闻2：悟空非空也带你学习 Python 新闻3：悟空非空也带你学习 C++ --> 普通会员 - 新闻专栏 普通会员新闻：1 普通会员新闻：2 --> VIP会员 - 专享专栏 vip会员新闻：1 vip会员新闻：2 源码归档 归档链接 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/security-management/authorization.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"shiro/shiro.html":{"url":"shiro/shiro.html","title":"shiro 安全管理","keywords":"","body":"Shiro 什么是 Shiro？ 官网：http://shiro.apache.org/ 是一款主流的 Java 安全框架，不依赖任何容器，可以运行在 Java SE 和 Java EE 项目中，它的主要作用是对访问系统的用户进行身份认证、授权、会话管理、加密等操作。 Shiro 就是用来解决安全管理的系统化框架。 Shiro 核心组件 用户、角色、权限 三者的关系是什么？ 给用户赋予角色 ,会给角色赋予权限。 UsernamePasswordToken Shiro 用来封装用户登录信息，使用用户的登录信息来创建令牌 Token。 SecurityManager Shiro 的核心部分，负责安全认证和授权。 Suject Shiro 的一个抽象概念，包含了用户信息。 Realm 开发者自定义的模块，根据项目的需求，验证和授权的逻辑全部写在 Realm 中。 AuthenticationInfo 用户的角色信息集合，认证时使用。 AuthorzationInfo 角色的权限信息集合，授权时使用。 DefaultWebSecurityManager 安全管理器，自定义的 Realm 需要注入到 DefaultWebSecurityManager 进行管理才能生效。 ShiroFilterFactoryBean 过滤器工厂，Shiro 的基本运行机制是开发者定制规则，Shiro 去执行，具体执行操作由 ShiroFilterFactoryBean 创建的每个 Filter 对象来完成。 Shiro 的运行机制如下图所示。 Spring Boot 整合 Shiro 1、创建 Spring Boot 应用，集成 Shiro 及相关组件，pom.xml org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web org.projectlombok lombok true org.apache.shiro shiro-spring 1.5.3 mysql mysql-connector-java com.baomidou mybatis-plus-boot-starter 3.3.1.tmp 2、自定义 Shiro 过滤器 public class AccoutRealm extends AuthorizingRealm { @Autowired private AccountService accountService; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { //获取当前登录的用户信息 Subject subject = SecurityUtils.getSubject(); Account account = (Account) subject.getPrincipal(); //设置角色，确定用户具备哪些角色 Set roles = new HashSet<>(); roles.add(account.getRole()); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(roles); //设置权限 info.addStringPermission(account.getPerms()); return info; } /** * 身份认证(登录验证) */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; Account account = accountService.findByUsername(token.getUsername()); if(account != null){ // 若是 密码不一致，shiro 抛出异常，表示密码不一致 return new SimpleAuthenticationInfo(account,account.getPassword(),getName()); } return null; //shiro 抛出异常，表示用户名不存在 } } 3、配置类 @Configuration public class ShiroConfig { @Bean public AccoutRealm accoutRealm(){ return new AccoutRealm(); } @Bean public DefaultWebSecurityManager securityManager(@Qualifier(\"accoutRealm\") AccoutRealm accoutRealm){ DefaultWebSecurityManager manager = new DefaultWebSecurityManager(); manager.setRealm(accoutRealm); return manager; } @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager securityManager){ ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); factoryBean.setSecurityManager(securityManager); return factoryBean; } } controller @Controller public class AccountController { @GetMapping(\"/{url}\") public String redirect(@PathVariable(\"url\") String url){ return url; } @PostMapping(\"/login\") public String login(String username, String password, Model model){ Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username,password); try { subject.login(token); Account account = (Account) subject.getPrincipal(); subject.getSession().setAttribute(\"account\",account); return \"index\"; } catch (UnknownAccountException e) { e.printStackTrace(); model.addAttribute(\"msg\",\"用户名错误！\"); return \"login\"; } catch (IncorrectCredentialsException e){ model.addAttribute(\"msg\",\"密码错误！\"); e.printStackTrace(); return \"login\"; } } @GetMapping(\"/unauth\") @ResponseBody public String unauth(){ return \"未授权，无法访问！\"; } @GetMapping(\"/logout\") public String logout(){ Subject subject = SecurityUtils.getSubject(); subject.logout(); return \"login\"; } } 编写认证和授权规则： 认证过滤器 anon：无需认证。 authc：必须认证。 authcBasic：需要通过 HTTPBasic 认证。 user：不一定通过认证，只要曾经被 Shiro 记录即可，比如：记住我。 授权过滤器 perms：必须拥有某个权限才能访问。 role：必须拥有某个角色才能访问。 port：请求的端口必须是指定值才可以。 rest：请求必须基于 RESTful，POST、PUT、GET、DELETE。 ssl：必须是安全的 URL 请求，协议 HTTPS。 创建 3 个页面，main.html、manage.html、administrator.html 访问权限如下： 1、必须登录才能访问 main.html 2、当前用户必须拥有 manage 授权才能访问 manage.html 3、当前用户必须拥有 administrator 角色才能访问 administrator.html 访问控制 不同请求需要满足设置好的权限，才能访问成功。 可以将不同的请求路径，设置不同的权限。只有符合指定的权限，才能正常访问。 import at.pollux.thymeleaf.shiro.dialect.ShiroDialect; import org.apache.shiro.spring.web.ShiroFilterFactoryBean; import org.apache.shiro.web.mgt.DefaultWebSecurityManager; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.Hashtable; import java.util.Map; @Configuration public class ShiroConfig { @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager securityManager){ ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); factoryBean.setSecurityManager(securityManager); //设置登录页面 factoryBean.setLoginUrl(\"/login\"); //权限设置 Map map = new Hashtable<>(); map.put(\"/main\",\"authc\"); map.put(\"/manage\",\"perms[manage]\"); map.put(\"/administrator\",\"roles[administrator]\"); factoryBean.setFilterChainDefinitionMap(map); //设置未授权页面 factoryBean.setUnauthorizedUrl(\"/unauth\"); return factoryBean; } @Bean // @Qualifier(\"同下面的方法名\") public DefaultWebSecurityManager securityManager(@Qualifier(\"accoutRealm\") AccoutRealm accoutRealm){ DefaultWebSecurityManager manager = new DefaultWebSecurityManager(); manager.setRealm(accoutRealm); return manager; } @Bean public AccoutRealm accoutRealm(){ return new AccoutRealm(); } } controller @Controller public class AccountController { @GetMapping(\"/{url}\") public String redirect(@PathVariable(\"url\") String url){ return url; } @PostMapping(\"/login\") public String login(String username, String password, Model model){ Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username,password); try { subject.login(token); //如果登录身份验证成功，执行下面代码 Account account = (Account) subject.getPrincipal(); subject.getSession().setAttribute(\"account\",account); return \"index\"; } catch (UnknownAccountException e) { e.printStackTrace(); model.addAttribute(\"msg\",\"用户名错误！\"); return \"login\"; } catch (IncorrectCredentialsException e){ model.addAttribute(\"msg\",\"密码错误！\"); e.printStackTrace(); return \"login\"; } } @GetMapping(\"/unauth\") @ResponseBody public String unauth(){ return \"未授权，无法访问！\"; } @GetMapping(\"/logout\") public String logout(){ Subject subject = SecurityUtils.getSubject(); subject.logout(); return \"login\"; } } Shiro 整合 Thymeleaf 1、pom.xml 引入依赖 com.github.theborakompanioni thymeleaf-extras-shiro 2.0.0 2、配置类添加 ShiroDialect @Bean public ShiroDialect shiroDialect(){ return new ShiroDialect(); } 3、index.html Title index 退出 main manage administrator 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/shiro/shiro.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"message-service/message-service.html":{"url":"message-service/message-service.html","title":"消息服务","keywords":"","body":"为什么要使用消息服务 在多数应用尤其是分布式系统中，消息服务是不可或缺的重要部分，它使用起来比较简单，同时解决了不少难题，例如异步处理、应用解耦、流量削锋、分布式事务管理等，使用消息服务可以实现一个高性能、高可用、高扩展的系统。 异步处理 应用解耦 流量削峰 分布式事务 1.订单支付成功后，写入消息表 2.定时扫描消息表消息写入到消息队列中 3.库存系统会立即读取到消息队列中的消息进行库存更新，同时添加消息处理状态 4.库存系统向消息队列中写入库存处理结果 5.订单系统会立即读取到消息队列中的库存处理状态。直接删除消息表数据，并写入到历史消息表 常用消息中间件介绍 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/message-service/message-service.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"message-service/rabbitMQ.html":{"url":"message-service/rabbitMQ.html","title":"rabbitMQ 消息中间件","keywords":"","body":"RabbitMQ 消息中间件 工作模式介绍 Work queues（工作队列模式） Publish/Subscribe（发布订阅模式） Routing（路由模式） Topics（通配符模式） RPC Headers（使用较少） 安装RabbitMQ 注意版本的兼容，3.8 版本需要Erlang语言包 20 以上的，不然不兼容，注意 1、在RabbitMQ官网上http://www.rabbitmq.com/install-windows.html 下载,如果是在Windows环境下安装RabbitMQ消息中间件还需要64位的Erlang语言包支持。 2、 RabbitMQ安装包依赖于Erlang语言包的支持，所以要先安装Erlang语言包，再安装RabbitMQ安装包。 3、RabbitMQ可视化效果展示, RabbitMQ默认提供了两个端口号5672和15672，其中5672用作服务端口号，15672用作可视化管理端口号。在浏览器上访问http://localhost:15672(用户名和密码均为guest) Spring Boot 整合 RabbitMQ 环境搭建 pom.xml org.springframework.boot spring-boot-starter-amqp org.springframework.boot spring-boot-starter-web application.xml spring: rabbitmq: host: localhost username: guest password: guest virtual-host: / port: 5672 Public/Subscribe 发布/订阅工作模式 1-基于api方式 1.1 交换器和队列进行绑定，定制中间件,并运行@Test @Autowired private AmqpAdmin amqpAdmin; // 定制中间件 @Test public void amqpAdmin(){ //定义fanout类型交换器 amqpAdmin.declareExchange(new FanoutExchange(\"fanout_exchange\")); //定义2个默认持久化队列，处理email和sms amqpAdmin.declareQueue(new Queue(\"fanout_queue_email\")); amqpAdmin.declareQueue(new Queue(\"fanout_queue_sms\")); //将队列分别与交换机进行绑定 amqpAdmin.declareBinding(new Binding(\"fanout_queue_email\", Binding.DestinationType.QUEUE,\"fanout_exchange\",\"\",null)); amqpAdmin.declareBinding(new Binding(\"fanout_queue_sms\",Binding.DestinationType.QUEUE, \"fanout_exchange\",\"\",null)); 1.2 消息发布者发布消息 先创建实体类，同时将实体类输出格式转换成json格式 package com.wukongnotnull.studyrabbitmq.domain; public class User { private Integer id; private String username; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } package com.wukongnotnull.studyrabbitmq.config; import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter; import org.springframework.amqp.support.converter.MessageConverter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfig { //将实体类转换成json格式呈现 @Bean public MessageConverter messageConverter(){ return new Jackson2JsonMessageConverter(); } } 消息发布者 @Autowired private RabbitTemplate rabbitTemplate; @Test public void pushPublisher(){ User user = new User(); user.setId(1); user.setUsername(\"zhangsan\"); rabbitTemplate.convertAndSend(\"fanout_exchange\",\"\",user); } 1.3 消费者消费消息 package com.wukongnotnull.studyrabbitmq.service; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class RabbitMQService { @RabbitListener(queues = \"fanout_queue_email\") public void pushConsumerEmail(Message message){ byte[] bytes = message.getBody(); String string = new String(bytes); System.out.println(\"邮件业务接收到消息\"+string); } @RabbitListener(queues = \"fanout_queue_sms\") public void pushConsumerSMS(Message message){ byte[] bytes = message.getBody(); String string = new String(bytes); System.out.println(\"sms业务接收到消息\"+string); } } 1.4 测试 2-基于配置类的方式 1、打开RabbitMQ消息配置类RabbitMQConfig，定义消息转换器、fanout类型的交换器、不同名称的消息队列以及将不同名称的消息队列与交换器绑定。 package com.wukongnotnull.studyrabbitmq.config; import org.springframework.amqp.core.*; import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter; import org.springframework.amqp.support.converter.MessageConverter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfig { //将实体类转换成json格式呈现 @Bean public MessageConverter messageConverter(){ return new Jackson2JsonMessageConverter(); } //创建 fanout类型的交换器 @Bean public Exchange fanout_exchange(){ return ExchangeBuilder.fanoutExchange(\"fanout_exchange\").build(); } //创建 存放email消息的持久化队列 @Bean public Queue fanout_queue_email(){ return new Queue(\"fanout_queue_email\"); } //创建存放 sms 消息的持久化队列 @Bean public Queue fanout_queue_sms(){ return new Queue(\"fanout_queue_sms\"); } //创建存放 weixin 消息的持久化队列 @Bean public Queue fanout_queue_wx(){ return new Queue(\"fanout_queue_wx\"); } //email消息队列绑定交换机 @Bean public Binding bindingEmail(){ return BindingBuilder.bind(fanout_queue_email()).to(fanout_exchange()).with(\"\").noargs(); } //sms消息队列绑定交换机 @Bean public Binding bindingSms(){ return BindingBuilder.bind(fanout_queue_sms()).to(fanout_exchange()).with(\"\").noargs(); } //wx消息队列绑定交换机 @Bean public Binding bindingWx(){ return BindingBuilder.bind(fanout_queue_wx()).to(fanout_exchange()).with(\"\").noargs(); } } 3-基于注解方式实现发布/订阅模式 package com.wukongnotnull.studyrabbitmq.service; import com.wukongnotnull.studyrabbitmq.domain.User; import org.springframework.amqp.rabbit.annotation.Exchange; import org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.QueueBinding; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class RabbitMQService { @RabbitListener(bindings =@QueueBinding(value = @Queue(\"fanout_queue_email\"), exchange = @Exchange(value = \"fanout_exchange\",type = \"fanout\"))) public void psubConsumerEmailAno(User user) { System.out.println(\"邮件业务接收到消息： \"+user); } @RabbitListener(bindings =@QueueBinding(value = @Queue(\"fanout_queue_sms\"),exchange = @Exchange(value = \"fanout_exchange\",type = \"fanout\"))) public void psubConsumerSmsAno(User user) { System.out.println(\"短信业务接收到消息： \"+user); } } Routing 路由工作模式 1.使用基于注解的方式定制消息组件和消息消费者 打开业务类RabbitMQService，在该类中使用@RabbitListener注解及其相关属性定制Routing路由模式的消息组件，并模拟编写消息消费者接收的方法。 package com.wukongnotnull.studyrabbitmq.service; import org.springframework.amqp.rabbit.annotation.Exchange; import org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.QueueBinding; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class RabbitMQService { @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \"routing_queue_error\"), exchange =@Exchange( value = \"routing_exchange\", type = \"direct\" ) , key = \"error_routing_key\" ) ) public void routingConsumerError(String message){ System.out.println(\"接收到error级别日志消息:\"+message); } @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \"routing_queue_all\"), exchange = @Exchange( value = \"routing_exchange\", type = \"direct\" ), key = {\"error_routing_key\",\"warning_routing_key\",\"info_routing_key\"} ) ) public void routingConsumerAll(String message){ System.out.println(\"接收到所有级别error,warning,info的日志消息:\"+message); } } 2.消息发送者发送消息 @Autowired private RabbitTemplate rabbitTemplate; @Test public void routingPublisher() { rabbitTemplate.convertAndSend(\"routing_exchange\", \"error_routing_key\", \"routing send : this is error message\"); } 3-测试结果 4-改造： 5-测试结果为： Topics通配符工作模式 “通配符交换机”（Topic Exchange）将路由键和某模式进行匹配。此时队列需要绑定在一个模式上。符号“#”匹配一个或多个词，符号“”仅匹配一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.”只会匹配到“audit.irs”。（这里与我们一般的正则表达式的“*”和“#”刚好相反，这里我们需要注意一下。） 举例： key: info.#.email.# 的队列 ---》邮件业务订阅该队列的消息 info.#.sms.# 的队列 ---》短信业务订阅该队列的消息 routingKey: info.email info.sms info.email.sms 1-使用注解方式定制消息组件和消息订阅者（消费者） package com.wukongnotnull.studyrabbitmq.service; import org.springframework.amqp.rabbit.annotation.Exchange; import org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.QueueBinding; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class RabbitMQService { @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \"topic_queue_email\"), exchange =@Exchange(value = \"topic_exchange\",type = \"topic\") , key = \"info.#.email.#\" )) public void topicConsumerEmail(String message){ System.out.println(\"邮件业务消费该消息：\"+message); } @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \"topic_queue_sms\"), exchange = @Exchange(value = \"topic_exchange\",type = \"topic\"), key = \"info.#.sms.#\" ) ) public void topicConsumerSMS(String message){ System.out.println(\"短信业务消费该消息：\"+message); } } 2-消息发送者发送消息 @Autowired private RabbitTemplate rabbitTemplate; @Test public void topicPublisher(){ //只发邮件 // rabbitTemplate.convertAndSend(\"topic_exchange\",\"info.email\",\"email: this is an email\"); //只发短信 // rabbitTemplate.convertAndSend(\"topic_exchange\",\"info.sms\",\"sms: this is a sms\"); //既发邮件也发短信 rabbitTemplate.convertAndSend(\"topic_exchange\",\"info.email.sms\",\"both: we are an email and a sms\"); } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/message-service/rabbitMQ.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"task-management/task-management.html":{"url":"task-management/task-management.html","title":"任务管理","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/task-management/task-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"task-management/asynch-call.html":{"url":"task-management/asynch-call.html","title":"异步调用","keywords":"","body":"无返回值异步任务调用 应用场景： 发送注册验证码 org.springframework.boot spring-boot-starter-web 1-application.java package com.wukongnotnull; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.scheduling.annotation.EnableAsync; @EnableAsync @SpringBootApplication public class SbTaskApplication { public static void main(String[] args) { SpringApplication.run(SbTaskApplication.class, args); } } 2-service package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） public interface MyAsyncService { public void sendSms(); } package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Service; @Service public class MyAsyncServiceImpl implements MyAsyncService{ @Async public void sendSms(){ long startTime = System.currentTimeMillis(); System.out.println(\"service--->sendSms-->发送短信进行中。。。\"); try { Thread.sleep(5000); }catch (Exception e){ e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\"service 共耗时\"+(endTime-startTime)); } } 3-controller package com.wukongnotnull.controller; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.service.MyAsyncService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class MyAsyncController { @Autowired private MyAsyncService myAsyncService; @GetMapping(\"/sendsms\") public String sendSms(){ System.out.println(\"controller-->sendSms--> 开始执行\"); myAsyncService.sendSms(); System.out.println(\"controller-->sendSms--> 执行结束\"); return \"短信验证码已发送，请稍后查收\"; } } 4-test 有返回值异步任务调用 2个方法 processA() 和 processB() 同时执行，不是先后执行 1-sevice @Service public class MyAsyncService { @Async public Future processA(){ System.out.println(\"MyAsyncService-->start processA\"); long startTime = System.currentTimeMillis(); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } int count=123; long endTime = System.currentTimeMillis(); System.out.println(\"MyAsyncService-->processA end ,total time cost \"+(endTime-startTime)); return new AsyncResult(count); } @Async public Future processB(){ System.out.println(\"MyAsyncService-->start processB\"); long startTime = System.currentTimeMillis(); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } int count=321; long endTime = System.currentTimeMillis(); System.out.println(\"MyAsyncService-->processB end ,total time cost \"+(endTime-startTime)); return new AsyncResult(count); } 2-controller @RequestMapping(\"/statistics\") public String statistics(){ long startTime = System.currentTimeMillis(); Future processA = myAsyncService.processA(); Future processB = myAsyncService.processB(); try { Integer totalCount=processA.get()+processB.get(); System.out.println(\"totalCount is\"+totalCount); } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\"AsyncController-->statistics-->total time is\"+(endTime-startTime)); return \"success\"; } 3-test 所谓异步就是2个方法同时执行 上述异步方法是有返回值的，这样主流程在执行异步方法时会有短暂阻塞，需要等待并获取异步方法的返回结果，而调用的两个异步方法会作为两个子线程并行执行，直到异步方法执行完成并返回结果，这样主流程会在最后一个异步方法返回结果后跳出阻塞状态。 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/task-management/asynch-call.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"task-management/timed-task.html":{"url":"task-management/timed-task.html","title":"定时任务","keywords":"","body":"定时任务介绍 @Scheduled注解 https://www.jianshu.com/p/1defb0f22ed1 定时任务实现 新建定时业务处理类 ScheduledTaskService 该类中编写定时任务处理方法使用 @Scheduled 注解声明了三个定时任务方法， 定制的执行规则基本相同，都是每隔1分钟重复执行一次定时任务 在使用 fixedDelay 属性的方法 scheduledTaskAfterSleep() 中，使用 Thread.sleep(10000 )模拟该定时任务处理耗时为10秒钟。 启动类 @EnableScheduling @SpringBootApplication public class SbTaskApplication { public static void main(String[] args) { SpringApplication.run(SbTaskApplication.class, args); } } service @Service public class ScheduledTaskService { private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); private Integer count1 = 1; private Integer count2 = 1; private Integer count3 = 1; //每隔1分钟，执行一次 @Scheduled(fixedRate = 60000) public void scheduledTaskImmediately() { System.out.println(String.format(\"fixedRate第%s次执行，当前时间为：%s\", count1++, dateFormat.format(new Date()))); } //每隔1分10秒（1分钟定时+业务处理时间10秒），执行一次 @Scheduled(fixedDelay = 60000) public void scheduledTaskAfterSleep() throws InterruptedException { System.out.println(String.format(\"fixedDelay第%s次执行，当前时间为：%s\", count2++, dateFormat.format(new Date()))); Thread.sleep(10000);//模拟业务处理时间 } //整秒输出 @Scheduled(cron = \"0 * * * * *\") public void scheduledTaskCron(){ System.out.println(String.format(\"cron第%s次执行，当前时间为：%s\", count3++, dateFormat.format(new Date()))); } } 启动启动类测试 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/task-management/timed-task.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"task-management/send-email.html":{"url":"task-management/send-email.html","title":"发送邮件","keywords":"","body":"发送纯文本邮件 pom.xml org.springframework.boot spring-boot-starter-mail application.yml spring.mail.host=smtp.qq.com spring.mail.port=587 spring.mail.username=1390128154@qq.com spring.mail.password=wvthphmybrqmhidf spring.mail.default-encoding=UTF-8 spring.mail.properties.mail.smtp.connectiontimeout=5000 spring.mail.properties.mail.smtp.timeout=3000 spring.mail.properties.mail.smtp.writetimeout=5000 service package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.stereotype.Service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.FileSystemResource; import org.springframework.mail.MailException; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSenderImpl; import org.springframework.mail.javamail.MimeMessageHelper; import javax.mail.MessagingException; import javax.mail.internet.MimeMessage; import java.io.File; @Service public class SendMailService { @Autowired private JavaMailSenderImpl mailSender; @Value(\"${spring.mail.username}\") private String from; /** * 发送纯文本邮件 * @param to 收件人地址 * @param subject 邮件标题 * @param text 邮件内容 */ public void sendSimpleEmail(String to,String subject,String text){ // 定制纯文本邮件信息SimpleMailMessage SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(text); try { // 发送邮件 mailSender.send(message); System.out.println(\"纯文本邮件发送成功\"); } catch (MailException e) { System.out.println(\"纯文本邮件发送失败 \"+e.getMessage()); e.printStackTrace(); } } } test package com.wukongnotnull.service; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.Context; //author: 悟空非空也（B站/知乎/公众号） @SpringBootTest class SendMailServiceTest { @Autowired private SendMailService sendMailService ; @Autowired private TemplateEngine templateEngine; FastStringWriter fastStringWriter; @Test void sendSimpleEmail() { sendMailService.sendSimpleEmail(\"1390128154@qq.com\",\"标题123\",\"内容123\"); } } 发送带附件和图片的文件 service package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.stereotype.Service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.FileSystemResource; import org.springframework.mail.MailException; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSenderImpl; import org.springframework.mail.javamail.MimeMessageHelper; import javax.mail.MessagingException; import javax.mail.internet.MimeMessage; import java.io.File; @Service public class SendMailService { @Autowired private JavaMailSenderImpl mailSender; @Value(\"${spring.mail.username}\") private String from; /** * 发送复杂邮件（包括静态资源和附件） * * @param to 收件人地址 * @param subject 邮件标题 * @param text 邮件内容 * @param filePath 附件地址 * @param rscId 静态资源唯一标识 * @param rscPath 静态资源地址 */ public void sendComplexEmail( String to, String subject, String text, String filePath, String rscId, String rscPath){ // 定制复杂邮件信息 MimeMessage MimeMessage message = mailSender.createMimeMessage(); try { // 使用 MimeMessageHelper 帮助类，并设置 multipart 多部件使用为 true MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(text, true); // 设置邮件静态资源 FileSystemResource res = new FileSystemResource(new File(rscPath)); helper.addInline(rscId, res); // 设置邮件附件 FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName, file); // 发送邮件 mailSender.send(message); System.out.println(\"复杂邮件发送成功\"); } catch (MessagingException e) { System.out.println(\"复杂邮件发送失败 \"+e.getMessage()); e.printStackTrace(); } } } test package com.wukongnotnull.service; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.Context; //author: 悟空非空也（B站/知乎/公众号） @SpringBootTest class SendMailServiceTest { @Autowired private SendMailService sendMailService ; @Autowired private TemplateEngine templateEngine; FastStringWriter fastStringWriter; @Test void sendComplexEmail() { StringBuffer text = new StringBuffer(); String rscId = \"img_2616\"; text.append(\"\"); text.append(\"这是邮件正文\"); text.append(\"\"); text.append(\"\"); sendMailService.sendComplexEmail(\"1390128154@qq.com\", \"带附件的邮件标题\", text.toString(), \"/Users/mac/Downloads/信1901班级人员名单.xlsx\", rscId, \"/Users/mac/Downloads/IMG_2616.JPG\"); } } 发送模板邮件 pom.xml org.springframework.boot spring-boot-starter-thymeleaf emailTemplate.html email 用户您好，你的验证码是 service package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.stereotype.Service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.FileSystemResource; import org.springframework.mail.MailException; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSenderImpl; import org.springframework.mail.javamail.MimeMessageHelper; import javax.mail.MessagingException; import javax.mail.internet.MimeMessage; import java.io.File; @Service public class SendMailService { @Autowired private JavaMailSenderImpl mailSender; @Value(\"${spring.mail.username}\") private String from; /** * 发送模板邮件 * @param to 收件人地址 * @param subject 邮件标题 * @param content 邮件内容 */ public void sendTemplateEmail(String to, String subject, String content) { MimeMessage message = mailSender.createMimeMessage(); try { // 使用MimeMessageHelper帮助类，并设置multipart多部件使用为true MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); // 发送邮件 mailSender.send(message); System.out.println(\"模板邮件发送成功\"); } catch (MessagingException e) { System.out.println(\"模板邮件发送失败 \"+e.getMessage()); e.printStackTrace(); } } } test import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.Context; 两个类无法识别 ，后续解决 package com.wukongnotnull.service; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.Context; //author: 悟空非空也（B站/知乎/公众号） @SpringBootTest class SendMailServiceTest { @Autowired private SendMailService sendMailService ; @Autowired private TemplateEngine templateEngine; @Test void sendTemplateEmail() { String to=\"1390128154@qq.com\"; String subject=\"【模板邮件】标题\"; // 使用模板邮件定制邮件正文内容 Context context = new Context(); context.setVariable(\"username\", \"悟空非空也\"); context.setVariable(\"code\", \"456123\"); // 使用TemplateEngine设置要处理的模板页面 String emailContent = templateEngine.process(\"emailTemplate\", context); // 发送模板邮件 sendMailService.sendTemplateEmail(to,subject,emailContent); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/task-management/send-email.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"task-management/integrate-quartz.html":{"url":"task-management/integrate-quartz.html","title":"整合 Quartz","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/task-management/integrate-quartz.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"actuator-intergrate/actuator-intergrate.html":{"url":"actuator-intergrate/actuator-intergrate.html","title":"指标监控","keywords":"","body":"引入依赖 org.springframework.boot spring-boot-starter-actuator 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/actuator-intergrate/actuator-intergrate.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "},"integrated-project/integrated-project.html":{"url":"integrated-project/integrated-project.html","title":"综合项目","keywords":"","body":"Spring Boot 综合项目实战 项目概述 系统开发及运行环境 Window 10 jdk 1.8 Maven 3.6 Mysql 8.x redis Idea 项目结构 前端素材 10.5系统环境搭建 10.6文章分页展示 10.7文章详情查看 10.8文章评论管理 10.9数据展示 10.10文章发布 10.11文章修改 10.12文章删除 10.13用户登录控制 10.14定时邮件发送 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-qingtong-wukongnote/integrated-project/integrated-project.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-20 08:00:11 "}}